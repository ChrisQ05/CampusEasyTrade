# 校园二手交易系统 - 核心算法与技术说明

## 第一部分：登录注册系统

### 1.1 系统入口界面

#### 功能概述
系统启动后首先进入登录注册入口界面，为用户提供四个选项：
- 用户登录
- 用户注册
- 进入管理后台
- 退出系统

#### 核心技术实现

**1. 界面绘制 (`drawLoginRegisterAdminEntryScreen`)**

```cpp
void drawLoginRegisterAdminEntryScreen() {
    BeginBatchDraw();  // 开始批量绘制，提高性能
    setbkcolor(RGB(240, 240, 240));  // 设置背景色
    cleardevice();  // 清空屏幕
    
    // 绘制系统标题
    settextcolor(RGB(52, 4, 98));
    settextstyle(40, 0, "Bauhaus 93");
    outtextxy(10, 10, "SimpTrade");
    
    // 绘制欢迎文字
    settextstyle(48, 0, "Bauhaus 93");
    outtextxy(60, 110, "欢迎来到SimpTrade校园二手交易系统");
    
    // 绘制四个功能按钮
    drawButton(300, 200, 200, 60, "登录");
    drawButton(300, 300, 200, 60, "注册");
    drawButton(300, 400, 200, 60, "进入管理后台");
    drawButton(300, 500, 200, 60, "退出系统");
    
    EndBatchDraw();  // 结束批量绘制，一次性显示
}
```

**技术要点：**
- **双缓冲技术**：使用 `BeginBatchDraw()` 和 `EndBatchDraw()` 实现双缓冲绘制，避免屏幕闪烁
- **RGB颜色系统**：使用 RGB 值精确控制界面配色
- **自定义按钮函数**：封装 `drawButton()` 函数，统一按钮样式

**2. 事件处理 (`handleLoginRegisterAdminEntryClick`)**

```cpp
void handleLoginRegisterAdminEntryClick(ExMessage msg) {
    if (msg.message == WM_LBUTTONDOWN) {  // 检测鼠标左键按下
        // 登录按钮点击检测
        if (msg.x >= 300 && msg.x <= 500 && msg.y >= 200 && msg.y <= 260) {
            g_currentScreen = SCREEN_USER_LOGIN;  // 切换到登录界面
            // 清空输入缓冲区
            g_loginUsernameBuffer[0] = '\0';
            g_loginPasswordBuffer[0] = '\0';
            g_inputBuffer[0] = '\0';
            g_activeInputBox = 0;
            return;
        }
        
        // 注册按钮点击检测
        if (msg.x >= 300 && msg.x <= 500 && msg.y >= 300 && msg.y <= 360) {
            g_currentScreen = SCREEN_USER_REGISTER;
            // 清空输入缓冲区
            g_loginUsernameBuffer[0] = '\0';
            g_loginPasswordBuffer[0] = '\0';
            g_inputBuffer[0] = '\0';
            g_activeInputBox = 0;
            return;
        }
        
        // 管理后台按钮点击检测
        if (msg.x >= 300 && msg.x <= 500 && msg.y >= 400 && msg.y <= 460) {
            g_currentScreen = SCREEN_ADMIN_LOGIN;
            // 清空输入缓冲区
            g_loginUsernameBuffer[0] = '\0';
            g_loginPasswordBuffer[0] = '\0';
            g_inputBuffer[0] = '\0';
            g_activeInputBox = 0;
            return;
        }
        
        // 退出系统按钮
        if (msg.x >= 300 && msg.x <= 500 && msg.y >= 500 && msg.y <= 560) {
            exit(0);  // 直接退出程序
        }
    }
}
```

**技术要点：**
- **矩形碰撞检测**：通过判断鼠标坐标是否在按钮矩形区域内来检测点击
- **状态机模式**：使用全局变量 `g_currentScreen` 管理界面状态切换
- **缓冲区管理**：切换界面前清空输入缓冲区，避免数据残留

---

### 1.2 用户登录界面

#### 功能概述
用户登录界面提供用户名和密码输入框，验证用户身份后进入主菜单。

#### 核心技术实现

**1. 界面绘制 (`drawUserLoginScreen`)**

```cpp
void drawUserLoginScreen() {
    BeginBatchDraw();
    setbkcolor(RGB(245, 245, 255));  // 浅蓝色背景
    cleardevice();
    
    // 绘制标题
    settextcolor(RGB(50, 50, 150));
    settextstyle(36, 0, "微软雅黑");
    outtextxy(300, 80, "用户登录");
    
    // 绘制用户名输入框
    settextcolor(BLACK);
    settextstyle(24, 0, "宋体");
    outtextxy(LOGIN_LABEL_START_X, 200, "用户名:");
    drawInputField(LOGIN_INPUT_START_X, 200, LOGIN_INPUT_WIDTH, 
                   LOGIN_FIELD_HEIGHT, g_loginUsernameBuffer, 
                   g_activeInputBox == 11);
    
    // 绘制密码输入框
    outtextxy(LOGIN_LABEL_START_X, 200 + LOGIN_FIELD_SPACING, "密码:");
    drawInputField(LOGIN_INPUT_START_X, 200 + LOGIN_FIELD_SPACING, 
                   LOGIN_INPUT_WIDTH, LOGIN_FIELD_HEIGHT, 
                   g_loginPasswordBuffer, g_activeInputBox == 12);
    
    // 绘制按钮
    drawButton(250, 400, 120, 50, "登录");
    drawButton(430, 400, 120, 50, "返回");
    
    EndBatchDraw();
}
```

**技术要点：**
- **输入框焦点管理**：通过 `g_activeInputBox` 变量标识当前激活的输入框
- **输入框高亮显示**：激活的输入框显示蓝色边框，未激活显示灰色边框
- **布局常量化**：使用宏定义管理界面布局参数，便于统一调整

**2. 输入框绘制函数 (`drawInputField`)**

```cpp
static void drawInputField(int inputX, int inputY, int inputWidth, 
                           int inputHeight, const char* bufferToDisplay, 
                           int isActive) {
    // 绘制输入框背景
    setfillcolor(WHITE);
    solidrectangle(inputX, inputY, inputX + inputWidth, inputY + inputHeight);
    
    // 绘制边框（激活时蓝色，未激活时灰色）
    setlinecolor(isActive ? BLUE : LIGHTGRAY);
    setlinestyle(PS_SOLID, 2);
    rectangle(inputX, inputY, inputX + inputWidth, inputY + inputHeight);
    
    // 绘制文本内容
    settextcolor(BLACK);
    settextstyle(20, 0, "宋体");
    
    // 文本溢出处理：只显示能容纳的部分
    int maxBytesCanDisplay = (inputWidth - 10) / textwidth("W");
    if (strlen(bufferToDisplay) > maxBytesCanDisplay) {
        // 显示末尾部分
        outtextxy(inputX + 5, inputY + (inputHeight - textheight("高")) / 2,
                  bufferToDisplay + (strlen(bufferToDisplay) - maxBytesCanDisplay));
    } else {
        outtextxy(inputX + 5, inputY + (inputHeight - textheight("高")) / 2, 
                  bufferToDisplay);
    }
}
```

**技术要点：**
- **文本溢出处理**：当输入内容超过输入框宽度时，自动显示末尾部分
- **垂直居中对齐**：计算文本高度，实现垂直居中显示
- **视觉反馈**：通过边框颜色变化提示用户当前焦点位置

**3. 登录验证逻辑 (`handleUserLoginClick`)**

```cpp
void handleUserLoginClick(ExMessage msg) {
    if (msg.message == WM_LBUTTONDOWN) {
        // 登录按钮点击
        if (msg.x >= 250 && msg.x <= 370 && msg.y >= 400 && msg.y <= 450) {
            saveInputBufferContent();  // 保存当前输入框内容
            
            char* inputUsername = g_loginUsernameBuffer;
            char* inputPassword = g_loginPasswordBuffer;
            
            // 1. 输入验证
            if (strlen(inputUsername) == 0 || strlen(inputPassword) == 0) {
                printf("用户名或密码不能为空！\n");
                return;
            }
            
            // 2. 用户验证
            bool loginSuccess = false;
            for (int i = 0; i < g_userCount; i++) {
                // 用户名匹配
                if (strcmp(g_users[i].username, inputUsername) == 0) {
                    // 密码匹配
                    if (strcmp(g_users[i].password, inputPassword) == 0) {
                        g_currentUser = &g_users[i];  // 设置当前登录用户
                        loginSuccess = true;
                        break;
                    }
                }
            }
            
            // 3. 登录结果处理
            if (loginSuccess) {
                printf("登录成功！欢迎 %s\n", g_currentUser->username);
                g_currentScreen = SCREEN_MAIN_MENU;  // 进入主菜单
            } else {
                printf("用户名或密码错误！\n");
            }
            
            // 清空输入
            g_activeInputBox = 0;
            g_inputBuffer[0] = '\0';
            return;
        }
        
        // 输入框焦点切换
        int clickedBox = 0;
        if (msg.x >= LOGIN_INPUT_START_X && 
            msg.x <= LOGIN_INPUT_START_X + LOGIN_INPUT_WIDTH &&
            msg.y >= 200 && msg.y <= 200 + LOGIN_FIELD_HEIGHT) {
            clickedBox = 11;  // 用户名输入框
        } else if (msg.x >= LOGIN_INPUT_START_X && 
                   msg.x <= LOGIN_INPUT_START_X + LOGIN_INPUT_WIDTH &&
                   msg.y >= 200 + LOGIN_FIELD_SPACING && 
                   msg.y <= 200 + LOGIN_FIELD_SPACING + LOGIN_FIELD_HEIGHT) {
            clickedBox = 12;  // 密码输入框
        }
        
        // 焦点切换逻辑
        if (clickedBox != 0 && clickedBox != g_activeInputBox) {
            saveInputBufferContent();  // 保存旧焦点的输入
            g_activeInputBox = clickedBox;
            loadInputBufferContent(g_activeInputBox);  // 加载新焦点的输入
        } else if (clickedBox == 0 && g_activeInputBox != 0) {
            saveInputBufferContent();  // 点击空白区域，失去焦点
            g_activeInputBox = 0;
        }
    }
}
```

**核心算法：**

1. **线性查找算法**：遍历用户数组，查找匹配的用户名和密码
   - 时间复杂度：O(n)，n 为用户数量
   - 空间复杂度：O(1)

2. **字符串比较**：使用 `strcmp()` 函数进行精确匹配
   - 区分大小写
   - 完全匹配才能登录成功

**安全性考虑：**
- 密码明文存储（实际项目中应使用哈希加密）
- 登录失败不提示具体是用户名还是密码错误（防止用户名枚举攻击）

---

### 1.3 用户注册界面

#### 功能概述
新用户通过注册界面创建账号，系统验证用户名唯一性后将用户信息保存到文件。

#### 核心技术实现

**1. 注册验证逻辑 (`handleUserRegisterClick`)**

```cpp
void handleUserRegisterClick(ExMessage msg) {
    if (msg.message == WM_LBUTTONDOWN) {
        // 注册按钮点击
        if (msg.x >= 250 && msg.x <= 370 && msg.y >= 400 && msg.y <= 450) {
            saveInputBufferContent();
            
            char* username = g_loginUsernameBuffer;
            char* password = g_loginPasswordBuffer;
            
            // 1. 输入验证
            if (strlen(username) == 0 || strlen(password) == 0) {
                printf("用户名或密码不能为空！\n");
                return;
            }
            
            // 2. 用户名唯一性检查
            for (int i = 0; i < g_userCount; i++) {
                if (strcmp(g_users[i].username, username) == 0) {
                    printf("用户名 '%s' 已存在，请更换！\n", username);
                    return;
                }
            }
            
            // 3. 用户数量限制检查
            if (g_userCount >= MAX_USERS) {
                printf("用户数量已达上限，无法注册！\n");
                return;
            }
            
            // 4. 创建新用户
            User newUser;
            strcpy_s(newUser.username, MAX_USERNAME_LEN, username);
            strcpy_s(newUser.password, MAX_PASSWORD_LEN, password);
            newUser.type = USER_TYPE_NORMAL;  // 默认为普通用户
            newUser.publishedItems = 0;
            newUser.ecoPoints = 0;
            newUser.creditPoints = 0;
            
            // 5. 添加到用户数组
            g_users[g_userCount++] = newUser;
            
            // 6. 持久化保存
            saveUsersToFile("users.txt");
            
            printf("用户 '%s' 注册成功！\n", username);
            
            // 7. 跳转到登录界面
            g_currentScreen = SCREEN_USER_LOGIN;
            g_loginUsernameBuffer[0] = '\0';
            g_loginPasswordBuffer[0] = '\0';
            g_inputBuffer[0] = '\0';
            g_activeInputBox = 0;
            return;
        }
    }
}
```

**核心算法：**

1. **用户名唯一性检查**
   - 算法：线性查找
   - 时间复杂度：O(n)
   - 优化方案：可使用哈希表将查找时间降至 O(1)

2. **数据验证流程**
   ```
   输入验证 → 唯一性检查 → 容量检查 → 创建用户 → 保存数据 → 界面跳转
   ```

**2. 用户数据持久化 (`saveUsersToFile`)**

```cpp
void saveUsersToFile(const char* filename) {
    FILE* fp = fopen(filename, "w");  // 以写模式打开文件
    if (fp == NULL) {
        fprintf(stderr, "错误: 无法打开用户数据文件进行写入！\n");
        return;
    }
    
    // 遍历所有用户，写入文件
    for (int i = 0; i < g_userCount; i++) {
        fprintf(fp, "%s,%s,%d,%d,%d,%d\n",
                g_users[i].username,
                g_users[i].password,
                g_users[i].type,
                g_users[i].publishedItems,
                g_users[i].ecoPoints,
                g_users[i].creditPoints);
    }
    
    fclose(fp);
    fprintf(stdout, "用户数据已保存！\n");
}
```

**数据格式：**
```
用户名,密码,用户类型,已发布物品数,环保积分,信誉积分
admin,admin,1,0,0,0
user1,pass123,0,5,100,85
```

**技术要点：**
- **CSV 格式存储**：使用逗号分隔值，便于读取和解析
- **全量覆盖写入**：每次保存都重写整个文件，保证数据一致性
- **错误处理**：文件打开失败时给出错误提示

---

### 1.4 输入缓冲区管理

#### 技术难点
由于系统中有多个输入框（用户名、密码、物品名称等），需要统一的输入管理机制。

#### 解决方案：双缓冲区设计

**1. 数据结构**

```cpp
// 通用输入缓冲区
char g_inputBuffer[MAX_INPUT_BUFFER_LEN] = "";

// 专用输入缓冲区
char g_loginUsernameBuffer[MAX_USERNAME_LEN] = "";
char g_loginPasswordBuffer[MAX_PASSWORD_LEN] = "";
char g_add_itemNameBuffer[MAX_NAME_LEN] = "";
char g_add_itemDescBuffer[MAX_DESC_LEN] = "";
// ... 其他输入缓冲区

// 当前激活的输入框ID
int g_activeInputBox = 0;
```

**2. 缓冲区映射关系**

| 输入框ID | 对应缓冲区 | 用途 |
|---------|-----------|------|
| 0 | 无 | 无焦点状态 |
| 1 | g_add_itemNameBuffer | 物品名称 |
| 2 | g_add_itemDescBuffer | 物品描述 |
| 3 | g_add_itemPriceBuffer | 物品价格 |
| 4 | g_add_itemContactBuffer | 联系方式 |
| 10 | g_search_keywordBuffer | 搜索关键词 |
| 11 | g_loginUsernameBuffer | 登录用户名 |
| 12 | g_loginPasswordBuffer | 登录密码 |

**3. 缓冲区操作函数**

```cpp
// 保存通用缓冲区内容到专用缓冲区
static void saveInputBufferContent() {
    switch (g_activeInputBox) {
        case 1: 
            strcpy_s(g_add_itemNameBuffer, MAX_NAME_LEN, g_inputBuffer); 
            break;
        case 2: 
            strcpy_s(g_add_itemDescBuffer, MAX_DESC_LEN, g_inputBuffer); 
            break;
        case 3: 
            strcpy_s(g_add_itemPriceBuffer, 20, g_inputBuffer); 
            break;
        case 4: 
            strcpy_s(g_add_itemContactBuffer, MAX_CONTACT_LEN, g_inputBuffer); 
            break;
        case 10: 
            strcpy_s(g_search_keywordBuffer, MAX_DESC_LEN, g_inputBuffer); 
            break;
        case 11: 
            strcpy_s(g_loginUsernameBuffer, MAX_USERNAME_LEN, g_inputBuffer); 
            break;
        case 12: 
            strcpy_s(g_loginPasswordBuffer, MAX_PASSWORD_LEN, g_inputBuffer); 
            break;
    }
}

// 加载专用缓冲区内容到通用缓冲区
static void loadInputBufferContent(int targetBox) {
    g_inputBuffer[0] = '\0';  // 先清空
    switch (targetBox) {
        case 1: 
            strcpy_s(g_inputBuffer, MAX_INPUT_BUFFER_LEN, g_add_itemNameBuffer); 
            break;
        case 2: 
            strcpy_s(g_inputBuffer, MAX_INPUT_BUFFER_LEN, g_add_itemDescBuffer); 
            break;
        // ... 其他case
        case 11: 
            strcpy_s(g_inputBuffer, MAX_INPUT_BUFFER_LEN, g_loginUsernameBuffer); 
            break;
        case 12: 
            strcpy_s(g_inputBuffer, MAX_INPUT_BUFFER_LEN, g_loginPasswordBuffer); 
            break;
    }
}
```

**4. 键盘输入处理**

```cpp
void handleKeyboardInput(ExMessage msg) {
    if (g_activeInputBox == 0) return;  // 无焦点时不处理
    
    if (msg.message == WM_CHAR) {
        char ch = msg.ch;
        
        // 退格键处理
        if (ch == '\b') {
            size_t len = strlen(g_inputBuffer);
            if (len > 0) {
                g_inputBuffer[len - 1] = '\0';  // 删除最后一个字符
            }
        }
        // 回车键处理
        else if (ch == '\r' || ch == '\n') {
            saveInputBufferContent();  // 保存输入
            g_activeInputBox = 0;  // 失去焦点
        }
        // 普通字符输入
        else if (ch >= 32 && ch <= 126) {  // 可打印ASCII字符
            size_t len = strlen(g_inputBuffer);
            if (len < MAX_INPUT_BUFFER_LEN - 1) {
                g_inputBuffer[len] = ch;
                g_inputBuffer[len + 1] = '\0';
            }
        }
    }
}
```

**技术要点：**
- **统一输入接口**：所有输入框共享同一个键盘事件处理函数
- **焦点管理**：通过 `g_activeInputBox` 变量控制输入目标
- **数据同步**：焦点切换时自动保存和加载数据
- **字符过滤**：只接受可打印ASCII字符，防止非法输入

---

## 小结

登录注册系统是整个应用的入口，实现了以下核心功能：

1. **用户身份验证**：通过用户名密码匹配验证用户身份
2. **用户注册管理**：支持新用户注册，确保用户名唯一性
3. **数据持久化**：用户信息保存到文件，程序重启后数据不丢失
4. **输入管理**：统一的输入缓冲区管理机制，支持多输入框切换
5. **界面状态管理**：使用状态机模式管理界面切换

**关键技术：**
- EasyX 图形库的使用
- 双缓冲绘制技术
- 鼠标事件处理
- 键盘输入处理
- 文件I/O操作
- 字符串处理
- 数据结构设计

---

**下一部分预告：主菜单系统与物品浏览功能**

