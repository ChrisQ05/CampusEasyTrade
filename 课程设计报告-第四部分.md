# 第四部分：信用评价系统与交易管理

## 4.1 系统架构概述

### 核心数据结构

信用评价系统由三个核心数据结构组成，形成完整的信用体系：

```
交易记录 (Transaction) ←→ 用户评价 (Review) ←→ 信誉档案 (UserCreditProfile)
```

**1. 交易记录结构体 (Transaction)**

```cpp
typedef struct {
    int transactionId;          // 交易ID（唯一标识）
    int itemId;                 // 关联的物品ID
    char sellerUsername[50];    // 卖家用户名
    char buyerUsername[50];     // 买家用户名
    float price;                // 交易价格
    time_t transactionTime;     // 交易时间（Unix时间戳）
    TransactionStatus status;   // 交易状态
    char notes[100];            // 交易备注
} Transaction;
```

**交易状态枚举：**
```cpp
typedef enum {
    TRANSACTION_PENDING = 0,    // 待确认
    TRANSACTION_COMPLETED = 1,  // 已完成
    TRANSACTION_CANCELLED = 2,  // 已取消
    TRANSACTION_DISPUTED = 3    // 纠纷中
} TransactionStatus;
```

**2. 用户评价结构体 (Review)**

```cpp
typedef struct {
    int reviewId;               // 评价ID（唯一标识）
    int transactionId;          // 关联的交易ID
    char reviewerUsername[50];  // 评价者用户名
    char reviewedUsername[50];  // 被评价者用户名
    RatingLevel rating;         // 评分等级（1-5星）
    char comment[200];          // 评价内容
    time_t reviewTime;          // 评价时间
    bool isSellerReview;        // 是否为对卖家的评价
} Review;
```

**评分等级枚举：**
```cpp
typedef enum {
    RATING_ONE_STAR = 1,    // 1星（差评）
    RATING_TWO_STARS = 2,   // 2星
    RATING_THREE_STARS = 3, // 3星（中评）
    RATING_FOUR_STARS = 4,  // 4星
    RATING_FIVE_STARS = 5   // 5星（好评）
} RatingLevel;
```

**3. 用户信誉档案结构体 (UserCreditProfile)**

```cpp
typedef struct {
    char username[50];          // 用户名
    int creditScore;            // 信誉分数
    CreditLevel creditLevel;    // 信誉等级
    int totalTransactions;      // 总交易数
    int completedTransactions;  // 完成交易数
    int cancelledTransactions;  // 取消交易数
    float averageRating;        // 平均评分
    int totalReviews;           // 总评价数
    int positiveReviews;        // 好评数（≥4星）
    int neutralReviews;         // 中评数（3星）
    int negativeReviews;        // 差评数（≤2星）
    time_t lastActivityTime;    // 最后活动时间
} UserCreditProfile;
```

**信誉等级枚举：**
```cpp
typedef enum {
    CREDIT_LEVEL_NEW = 0,       // 新手 (0-50分)
    CREDIT_LEVEL_BRONZE = 1,    // 青铜 (51-100分)
    CREDIT_LEVEL_SILVER = 2,    // 白银 (101-200分)
    CREDIT_LEVEL_GOLD = 3,      // 黄金 (201-500分)
    CREDIT_LEVEL_PLATINUM = 4,  // 铂金 (501-1000分)
    CREDIT_LEVEL_DIAMOND = 5    // 钻石 (1001+分)
} CreditLevel;
```

### 全局数据存储

```cpp
// 交易记录数组
Transaction g_transactions[MAX_TRANSACTIONS];  // 最多1000条交易
int g_transactionCount = 0;

// 评价记录数组
Review g_reviews[MAX_REVIEWS_PER_USER * MAX_USERS];  // 最多10000条评价
int g_reviewCount = 0;

// 信誉档案数组
UserCreditProfile g_creditProfiles[MAX_USERS];  // 最多100个用户档案
```

---

## 4.2 交易管理系统

### 4.2.1 交易ID生成算法

```cpp
static int getNextTransactionId() {
    if (g_transactionCount == 0) {
        return 10001;  // 初始交易ID从10001开始
    }
    
    // 查找当前最大ID
    int maxId = 0;
    for (int i = 0; i < g_transactionCount; i++) {
        if (g_transactions[i].transactionId > maxId) {
            maxId = g_transactions[i].transactionId;
        }
    }
    
    return maxId + 1;
}
```

**算法分析：**
- **时间复杂度**：O(n)，n为交易总数
- **空间复杂度**：O(1)
- **优化方案**：维护全局最大ID变量，复杂度降至O(1)

```cpp
// 优化版本
static int g_maxTransactionId = 10000;

static int getNextTransactionId() {
    return ++g_maxTransactionId;
}
```

### 4.2.2 创建交易

```cpp
int createTransaction(int itemId, const char* sellerUsername, 
                     const char* buyerUsername, float price) {
    // 1. 容量检查
    if (g_transactionCount >= MAX_TRANSACTIONS) {
        printf("错误：交易记录已达到最大数量限制！\n");
        return -1;
    }
    
    // 2. 创建新交易
    Transaction newTransaction;
    newTransaction.transactionId = getNextTransactionId();
    newTransaction.itemId = itemId;
    strcpy_s(newTransaction.sellerUsername, MAX_USERNAME_LEN, sellerUsername);
    strcpy_s(newTransaction.buyerUsername, MAX_USERNAME_LEN, buyerUsername);
    newTransaction.price = price;
    newTransaction.transactionTime = time(NULL);  // 获取当前时间
    newTransaction.status = TRANSACTION_PENDING;  // 初始状态为待确认
    strcpy_s(newTransaction.notes, 100, "");
    
    // 3. 添加到数组
    g_transactions[g_transactionCount] = newTransaction;
    g_transactionCount++;
    
    printf("交易创建成功！交易ID: %d\n", newTransaction.transactionId);
    return newTransaction.transactionId;
}
```

**核心流程：**
```
输入：物品ID，卖家，买家，价格
输出：交易ID / -1（失败）

流程：
1. 容量检查
   if g_transactionCount >= MAX_TRANSACTIONS:
       return FAIL

2. 生成交易ID
   transactionId = getNextTransactionId()

3. 填充交易信息
   transaction.itemId = itemId
   transaction.seller = sellerUsername
   transaction.buyer = buyerUsername
   transaction.price = price
   transaction.time = getCurrentTime()
   transaction.status = PENDING

4. 添加到数组
   g_transactions[g_transactionCount++] = transaction

5. 返回交易ID
   return transactionId

时间复杂度：O(1)（优化后的ID生成）
空间复杂度：O(1)
```

### 4.2.3 交易状态更新

```cpp
int updateTransactionStatus(int transactionId, TransactionStatus newStatus) {
    // 1. 查找交易
    Transaction* transaction = findTransactionById(transactionId);
    if (transaction == NULL) {
        printf("错误：未找到交易ID %d\n", transactionId);
        return -1;
    }
    
    // 2. 记录旧状态
    TransactionStatus oldStatus = transaction->status;
    
    // 3. 更新状态
    transaction->status = newStatus;
    
    // 4. 触发信誉更新（状态变为已完成时）
    if (newStatus == TRANSACTION_COMPLETED && oldStatus != TRANSACTION_COMPLETED) {
        updateUserCreditProfile(transaction->sellerUsername);
        updateUserCreditProfile(transaction->buyerUsername);
    }
    
    printf("交易状态更新成功！交易ID: %d, 新状态: %d\n", transactionId, newStatus);
    return 0;
}
```

**状态转换图：**
```
PENDING (待确认)
    ↓
    ├→ COMPLETED (已完成) → 触发信誉更新
    ├→ CANCELLED (已取消) → 扣除信誉分
    └→ DISPUTED (纠纷中)  → 暂停信誉更新
```

### 4.2.4 交易查找算法

```cpp
Transaction* findTransactionById(int transactionId) {
    for (int i = 0; i < g_transactionCount; i++) {
        if (g_transactions[i].transactionId == transactionId) {
            return &g_transactions[i];
        }
    }
    return NULL;
}
```

**算法分析：**
- **算法类型**：线性查找
- **时间复杂度**：O(n)
- **优化方案**：使用哈希表，复杂度降至O(1)


---

## 4.3 用户评价系统

### 4.3.1 创建评价

```cpp
int createReview(int transactionId, const char* reviewerUsername, 
                const char* reviewedUsername, RatingLevel rating, 
                const char* comment, bool isSellerReview) {
    // 1. 容量检查
    if (g_reviewCount >= MAX_REVIEWS_PER_USER * MAX_USERS) {
        printf("错误：评价记录已达到最大数量限制！\n");
        return -1;
    }
    
    // 2. 重复评价检查
    for (int i = 0; i < g_reviewCount; i++) {
        if (g_reviews[i].transactionId == transactionId && 
            strcmp(g_reviews[i].reviewerUsername, reviewerUsername) == 0 &&
            g_reviews[i].isSellerReview == isSellerReview) {
            printf("错误：您已经对此交易进行过评价！\n");
            return -1;
        }
    }
    
    // 3. 创建新评价
    Review newReview;
    newReview.reviewId = getNextReviewId();
    newReview.transactionId = transactionId;
    strcpy_s(newReview.reviewerUsername, MAX_USERNAME_LEN, reviewerUsername);
    strcpy_s(newReview.reviewedUsername, MAX_USERNAME_LEN, reviewedUsername);
    newReview.rating = rating;
    strcpy_s(newReview.comment, MAX_REVIEW_LENGTH, comment);
    newReview.reviewTime = time(NULL);
    newReview.isSellerReview = isSellerReview;
    
    // 4. 添加到数组
    g_reviews[g_reviewCount] = newReview;
    g_reviewCount++;
    
    // 5. 更新被评价用户的信誉档案
    updateUserCreditProfile(reviewedUsername);
    
    printf("评价提交成功！评价ID: %d\n", newReview.reviewId);
    return newReview.reviewId;
}
```

**核心算法：重复评价检查**

```
输入：交易ID，评价者，评价类型
输出：是否已评价

算法：
for each review in g_reviews:
    if review.transactionId == transactionId AND
       review.reviewer == reviewerUsername AND
       review.isSellerReview == isSellerReview:
        return TRUE  // 已评价

return FALSE  // 未评价

时间复杂度：O(n)，n为评价总数
空间复杂度：O(1)

优化方案：使用哈希表存储 (transactionId, reviewer, type) → reviewId
时间复杂度：O(1)
```

### 4.3.2 计算平均评分

```cpp
float calculateAverageRating(const char* username) {
    int totalRating = 0;
    int reviewCount = 0;
    
    // 遍历所有评价，累加该用户收到的评分
    for (int i = 0; i < g_reviewCount; i++) {
        if (strcmp(g_reviews[i].reviewedUsername, username) == 0) {
            totalRating += g_reviews[i].rating;
            reviewCount++;
        }
    }
    
    // 计算平均值
    return reviewCount > 0 ? (float)totalRating / reviewCount : 0.0f;
}
```

**算法分析：**
```
输入：用户名
输出：平均评分（0.0-5.0）

算法：
totalRating = 0
reviewCount = 0

for each review in g_reviews:
    if review.reviewedUsername == username:
        totalRating += review.rating
        reviewCount++

if reviewCount > 0:
    return totalRating / reviewCount
else:
    return 0.0

时间复杂度：O(n)，n为评价总数
空间复杂度：O(1)

优化方案：在信誉档案中缓存平均评分，每次新增评价时增量更新
averageRating = (averageRating × totalReviews + newRating) / (totalReviews + 1)
时间复杂度：O(1)
```

### 4.3.3 显示用户评价

```cpp
void displayUserReviews(const char* username) {
    printf("\n--- %s 收到的评价 ---\n", username);
    printf("评价ID  交易ID  评价者    评分  评价内容                    时间\n");
    printf("------ ------ -------- ----- ---------------------------- --------------------\n");
    
    int count = 0;
    for (int i = 0; i < g_reviewCount; i++) {
        if (strcmp(g_reviews[i].reviewedUsername, username) == 0) {
            char timeStr[20];
            strftime(timeStr, sizeof(timeStr), "%Y-%m-%d %H:%M", 
                    localtime(&g_reviews[i].reviewTime));
            
            printf("%-6d %-6d %-8s %-5d %-30s %s\n",
                   g_reviews[i].reviewId,
                   g_reviews[i].transactionId,
                   g_reviews[i].reviewerUsername,
                   g_reviews[i].rating,
                   g_reviews[i].comment,
                   timeStr);
            count++;
        }
    }
    
    if (count == 0) {
        printf("暂无评价记录\n");
    }
    printf("----------------------------------------\n");
}
```

---

## 4.4 信誉计算系统

### 4.4.1 信誉分数计算算法

这是整个系统最核心的算法，决定了用户的信誉等级。

```cpp
int calculateCreditScore(const char* username) {
    int score = 0;
    int completedTransactions = 0;
    int cancelledTransactions = 0;
    float avgRating = calculateAverageRating(username);
    
    // === 1. 交易数据统计 ===
    for (int i = 0; i < g_transactionCount; i++) {
        if (strcmp(g_transactions[i].sellerUsername, username) == 0 ||
            strcmp(g_transactions[i].buyerUsername, username) == 0) {
            
            if (g_transactions[i].status == TRANSACTION_COMPLETED) {
                completedTransactions++;
                score += 10;  // 每完成一笔交易加10分
            } 
            else if (g_transactions[i].status == TRANSACTION_CANCELLED) {
                cancelledTransactions++;
                score -= 5;   // 每取消一笔交易扣5分
            }
        }
    }
    
    // === 2. 评分加成 ===
    if (avgRating >= 4.5) {
        score += 50;  // 优秀评分
    } else if (avgRating >= 4.0) {
        score += 30;  // 良好评分
    } else if (avgRating >= 3.5) {
        score += 10;  // 中等评分
    } else if (avgRating >= 3.0) {
        score += 0;   // 及格评分
    } else if (avgRating >= 2.0) {
        score -= 20;  // 较差评分
    } else {
        score -= 50;  // 很差评分
    }
    
    // === 3. 确保分数非负 ===
    return score > 0 ? score : 0;
}
```

**算法详解：**

**评分规则表：**

| 因素 | 条件 | 分数变化 |
|------|------|---------|
| 完成交易 | 每笔 | +10分 |
| 取消交易 | 每笔 | -5分 |
| 平均评分 | ≥4.5星 | +50分 |
| 平均评分 | ≥4.0星 | +30分 |
| 平均评分 | ≥3.5星 | +10分 |
| 平均评分 | ≥3.0星 | +0分 |
| 平均评分 | ≥2.0星 | -20分 |
| 平均评分 | <2.0星 | -50分 |

**计算示例：**

```
用户A的交易记录：
- 完成交易：15笔 → 15 × 10 = 150分
- 取消交易：2笔  → 2 × (-5) = -10分
- 平均评分：4.6星 → +50分

总分 = 150 - 10 + 50 = 190分
等级 = 白银（101-200分）
```

**时间复杂度分析：**
```
设：
- n = 交易总数
- m = 评价总数

calculateCreditScore():
  - 遍历交易：O(n)
  - 计算平均评分：O(m)
  - 总计：O(n + m)

优化方案：缓存统计数据
- 在信誉档案中维护 completedTransactions, cancelledTransactions
- 每次交易状态变化时增量更新
- 时间复杂度降至：O(1)
```

### 4.4.2 信誉等级计算

```cpp
CreditLevel calculateCreditLevel(int creditScore) {
    if (creditScore <= 50) return CREDIT_LEVEL_NEW;       // 新手
    if (creditScore <= 100) return CREDIT_LEVEL_BRONZE;   // 青铜
    if (creditScore <= 200) return CREDIT_LEVEL_SILVER;   // 白银
    if (creditScore <= 500) return CREDIT_LEVEL_GOLD;     // 黄金
    if (creditScore <= 1000) return CREDIT_LEVEL_PLATINUM;// 铂金
    return CREDIT_LEVEL_DIAMOND;                          // 钻石
}
```

**等级分布图：**
```
钻石 ████████████████████████████████ 1001+
铂金 ████████████████████ 501-1000
黄金 ████████████ 201-500
白银 ██████ 101-200
青铜 ███ 51-100
新手 █ 0-50
```

**算法特点：**
- **时间复杂度**：O(1)，只需要简单的条件判断
- **空间复杂度**：O(1)
- **可扩展性**：易于调整等级阈值


### 4.4.3 更新用户信誉档案

这是信誉系统的核心函数，负责重新计算用户的所有信誉数据。

```cpp
void updateUserCreditProfile(const char* username) {
    // === 1. 查找或创建信誉档案 ===
    int profileIndex = -1;
    for (int i = 0; i < MAX_USERS; i++) {
        if (strcmp(g_creditProfiles[i].username, username) == 0) {
            profileIndex = i;
            break;
        }
    }
    
    // 如果档案不存在，创建新档案
    if (profileIndex == -1) {
        for (int i = 0; i < MAX_USERS; i++) {
            if (strlen(g_creditProfiles[i].username) == 0) {
                profileIndex = i;
                strcpy_s(g_creditProfiles[i].username, MAX_USERNAME_LEN, username);
                break;
            }
        }
    }
    
    if (profileIndex == -1) {
        printf("错误：无法创建用户信誉档案\n");
        return;
    }
    
    UserCreditProfile* profile = &g_creditProfiles[profileIndex];
    
    // === 2. 重置所有统计数据 ===
    profile->totalTransactions = 0;
    profile->completedTransactions = 0;
    profile->cancelledTransactions = 0;
    profile->totalReviews = 0;
    profile->positiveReviews = 0;
    profile->neutralReviews = 0;
    profile->negativeReviews = 0;
    
    // === 3. 统计交易数据 ===
    for (int i = 0; i < g_transactionCount; i++) {
        if (strcmp(g_transactions[i].sellerUsername, username) == 0 ||
            strcmp(g_transactions[i].buyerUsername, username) == 0) {
            
            profile->totalTransactions++;
            
            if (g_transactions[i].status == TRANSACTION_COMPLETED) {
                profile->completedTransactions++;
            } else if (g_transactions[i].status == TRANSACTION_CANCELLED) {
                profile->cancelledTransactions++;
            }
        }
    }
    
    // === 4. 统计评价数据 ===
    for (int i = 0; i < g_reviewCount; i++) {
        if (strcmp(g_reviews[i].reviewedUsername, username) == 0) {
            profile->totalReviews++;
            
            if (g_reviews[i].rating >= 4) {
                profile->positiveReviews++;  // 好评（4-5星）
            } else if (g_reviews[i].rating >= 3) {
                profile->neutralReviews++;   // 中评（3星）
            } else {
                profile->negativeReviews++;  // 差评（1-2星）
            }
        }
    }
    
    // === 5. 计算平均评分和信誉分数 ===
    profile->averageRating = calculateAverageRating(username);
    profile->creditScore = calculateCreditScore(username);
    profile->creditLevel = calculateCreditLevel(profile->creditScore);
    profile->lastActivityTime = time(NULL);
}
```

**算法流程图：**
```
输入：用户名
输出：更新后的信誉档案

流程：
1. 查找/创建档案
   ├─ 档案存在 → 使用现有档案
   └─ 档案不存在 → 创建新档案

2. 重置统计数据
   totalTransactions = 0
   completedTransactions = 0
   ...

3. 遍历交易记录
   for each transaction:
       if 用户参与:
           totalTransactions++
           if 已完成: completedTransactions++
           if 已取消: cancelledTransactions++

4. 遍历评价记录
   for each review:
       if 评价对象是该用户:
           totalReviews++
           if rating >= 4: positiveReviews++
           if rating == 3: neutralReviews++
           if rating <= 2: negativeReviews++

5. 计算综合指标
   averageRating = calculateAverageRating()
   creditScore = calculateCreditScore()
   creditLevel = calculateCreditLevel(creditScore)
   lastActivityTime = now()

时间复杂度：O(n + m)
- n = 交易总数
- m = 评价总数
空间复杂度：O(1)
```

### 4.4.4 显示信誉档案

```cpp
void displayUserCreditProfile(const char* username) {
    // 查找用户信誉档案
    UserCreditProfile* profile = NULL;
    for (int i = 0; i < MAX_USERS; i++) {
        if (strcmp(g_creditProfiles[i].username, username) == 0) {
            profile = &g_creditProfiles[i];
            break;
        }
    }
    
    if (profile == NULL) {
        printf("未找到用户 %s 的信誉档案\n", username);
        return;
    }
    
    const char* levelNames[] = {"新手", "青铜", "白银", "黄金", "铂金", "钻石"};
    
    printf("\n=== %s 的信誉档案 ===\n", username);
    printf("信誉等级: %s (分数: %d)\n", 
           levelNames[profile->creditLevel], profile->creditScore);
    printf("平均评分: %.1f/5.0\n", profile->averageRating);
    printf("总交易数: %d (完成: %d, 取消: %d)\n", 
           profile->totalTransactions, 
           profile->completedTransactions, 
           profile->cancelledTransactions);
    printf("总评价数: %d (好评: %d, 中评: %d, 差评: %d)\n",
           profile->totalReviews, 
           profile->positiveReviews, 
           profile->neutralReviews, 
           profile->negativeReviews);
    
    // 计算好评率
    if (profile->totalReviews > 0) {
        float positiveRate = (float)profile->positiveReviews / 
                            profile->totalReviews * 100;
        printf("好评率: %.1f%%\n", positiveRate);
    }
    
    // 显示最后活动时间
    char timeStr[20];
    strftime(timeStr, sizeof(timeStr), "%Y-%m-%d %H:%M", 
            localtime(&profile->lastActivityTime));
    printf("最后活动: %s\n", timeStr);
    printf("========================\n");
}
```

**输出示例：**
```
=== user1 的信誉档案 ===
信誉等级: 黄金 (分数: 285)
平均评分: 4.6/5.0
总交易数: 25 (完成: 23, 取消: 2)
总评价数: 18 (好评: 16, 中评: 2, 差评: 0)
好评率: 88.9%
最后活动: 2024-11-18 15:30
========================
```

---

## 4.5 数据持久化

### 4.5.1 交易数据保存

```cpp
int saveTransactionsToFile(const char* filename) {
    FILE* fp = fopen(filename, "w");
    if (fp == NULL) return -1;
    
    for (int i = 0; i < g_transactionCount; i++) {
        fprintf(fp, "%d,%d,%s,%s,%.2f,%lld,%d,%s\n",
                g_transactions[i].transactionId,
                g_transactions[i].itemId,
                g_transactions[i].sellerUsername,
                g_transactions[i].buyerUsername,
                g_transactions[i].price,
                (long long)g_transactions[i].transactionTime,
                g_transactions[i].status,
                g_transactions[i].notes);
    }
    
    fclose(fp);
    return g_transactionCount;
}
```

**数据格式：**
```
交易ID,物品ID,卖家,买家,价格,时间戳,状态,备注
10001,1015,user1,user2,150.00,1731849600,1,
10002,1019,user2,user3,20.00,1731849700,1,
```

### 4.5.2 交易数据加载

```cpp
int loadTransactionsFromFile(const char* filename) {
    FILE* fp = fopen(filename, "r");
    if (fp == NULL) {
        g_transactionCount = 0;
        return 0;
    }
    
    g_transactionCount = 0;
    char line[512];
    
    while (g_transactionCount < MAX_TRANSACTIONS && 
           fgets(line, sizeof(line), fp) != NULL) {
        
        Transaction* t = &g_transactions[g_transactionCount];
        long long tempTime = 0;
        
        int result = sscanf(line, "%d,%d,%[^,],%[^,],%f,%lld,%d,%[^\n,]",
                   &t->transactionId, &t->itemId, 
                   t->sellerUsername, t->buyerUsername,
                   &t->price, &tempTime, &t->status, t->notes);
        
        if (result >= 7) {  // 至少读取7个字段
            t->transactionTime = (time_t)tempTime;
            if (result < 8) {
                t->notes[0] = '\0';  // 备注可以为空
            }
            g_transactionCount++;
        }
    }
    
    fclose(fp);
    return g_transactionCount;
}
```

**技术要点：**
1. **使用 fgets + sscanf**：比 fscanf 更灵活，能处理格式异常
2. **时间戳转换**：Unix时间戳（long long）与 time_t 的转换
3. **容错处理**：备注字段可以为空，result >= 7 即可接受

### 4.5.3 增量保存优化

```cpp
int appendTransactionToFile(const char* filename, const Transaction* transaction) {
    FILE* fp = fopen(filename, "a");  // 追加模式
    if (fp == NULL || transaction == NULL) {
        if (fp != NULL) fclose(fp);
        return -1;
    }
    
    fprintf(fp, "%d,%d,%s,%s,%.2f,%lld,%d,%s\n",
            transaction->transactionId,
            transaction->itemId,
            transaction->sellerUsername,
            transaction->buyerUsername,
            transaction->price,
            (long long)transaction->transactionTime,
            transaction->status,
            transaction->notes);
    
    fclose(fp);
    return 0;
}
```

**优化效果：**
- **全量保存**：O(n)，需要写入所有交易
- **增量保存**：O(1)，只写入新交易
- **适用场景**：新增交易时使用增量保存，修改交易时使用全量保存

---

## 4.6 高级功能

### 4.6.1 信誉排行榜

```cpp
void displayTopRatedUsers(int count) {
    printf("\n=== 评分最高的用户 (前%d名) ===\n", count);
    printf("排名  用户名    平均评分  信誉等级  总评价数\n");
    printf("---- -------- -------- -------- --------\n");
    
    // 简单的选择排序
    for (int i = 0; i < count && i < MAX_USERS; i++) {
        float maxRating = 0;
        int maxIndex = -1;
        
        // 找到未排序部分的最大值
        for (int j = 0; j < MAX_USERS; j++) {
            if (strlen(g_creditProfiles[j].username) > 0 && 
                g_creditProfiles[j].averageRating > maxRating) {
                maxRating = g_creditProfiles[j].averageRating;
                maxIndex = j;
            }
        }
        
        if (maxIndex != -1) {
            const char* levelNames[] = {"新手", "青铜", "白银", "黄金", "铂金", "钻石"};
            printf("%-4d %-8s %-8.1f %-8s %-8d\n",
                   i + 1, 
                   g_creditProfiles[maxIndex].username,
                   g_creditProfiles[maxIndex].averageRating,
                   levelNames[g_creditProfiles[maxIndex].creditLevel],
                   g_creditProfiles[maxIndex].totalReviews);
            
            g_creditProfiles[maxIndex].averageRating = 0;  // 标记已使用
        }
    }
    printf("========================\n");
}
```

**算法分析：**
- **算法类型**：选择排序（Selection Sort）
- **时间复杂度**：O(k × n)，k为显示数量，n为用户总数
- **空间复杂度**：O(1)

**优化方案：**
```cpp
// 使用快速排序 + 部分排序
void displayTopRatedUsersOptimized(int count) {
    // 1. 复制有效用户到临时数组
    UserCreditProfile* validUsers[MAX_USERS];
    int validCount = 0;
    
    for (int i = 0; i < MAX_USERS; i++) {
        if (strlen(g_creditProfiles[i].username) > 0) {
            validUsers[validCount++] = &g_creditProfiles[i];
        }
    }
    
    // 2. 使用qsort排序
    qsort(validUsers, validCount, sizeof(UserCreditProfile*), compareByRating);
    
    // 3. 显示前k个
    for (int i = 0; i < count && i < validCount; i++) {
        // 显示 validUsers[i]
    }
}

// 比较函数
int compareByRating(const void* a, const void* b) {
    UserCreditProfile* p1 = *(UserCreditProfile**)a;
    UserCreditProfile* p2 = *(UserCreditProfile**)b;
    
    if (p1->averageRating > p2->averageRating) return -1;  // 降序
    if (p1->averageRating < p2->averageRating) return 1;
    return 0;
}

// 时间复杂度：O(n log n)
```


### 4.6.2 最活跃用户排行

```cpp
void displayMostActiveUsers(int count) {
    printf("\n=== 最活跃的用户 (前%d名) ===\n", count);
    printf("排名  用户名    总交易数  信誉分数  信誉等级\n");
    printf("---- -------- -------- -------- --------\n");
    
    for (int i = 0; i < count && i < MAX_USERS; i++) {
        int maxTransactions = 0;
        int maxIndex = -1;
        
        for (int j = 0; j < MAX_USERS; j++) {
            if (strlen(g_creditProfiles[j].username) > 0 && 
                g_creditProfiles[j].totalTransactions > maxTransactions) {
                maxTransactions = g_creditProfiles[j].totalTransactions;
                maxIndex = j;
            }
        }
        
        if (maxIndex != -1) {
            const char* levelNames[] = {"新手", "青铜", "白银", "黄金", "铂金", "钻石"};
            printf("%-4d %-8s %-8d %-8d %-8s\n",
                   i + 1, 
                   g_creditProfiles[maxIndex].username,
                   g_creditProfiles[maxIndex].totalTransactions,
                   g_creditProfiles[maxIndex].creditScore,
                   levelNames[g_creditProfiles[maxIndex].creditLevel]);
            
            g_creditProfiles[maxIndex].totalTransactions = 0;  // 标记已使用
        }
    }
    printf("========================\n");
}
```

---

## 4.7 技术难点与解决方案

### 难点1：数据一致性问题

**问题：**交易、评价、信誉档案三者之间的数据一致性如何保证？

**解决方案：**

1. **级联更新机制**
```cpp
// 交易状态变化 → 自动更新信誉档案
int updateTransactionStatus(int transactionId, TransactionStatus newStatus) {
    transaction->status = newStatus;
    
    if (newStatus == TRANSACTION_COMPLETED) {
        updateUserCreditProfile(transaction->sellerUsername);  // 级联更新
        updateUserCreditProfile(transaction->buyerUsername);
    }
    
    return 0;
}

// 创建评价 → 自动更新信誉档案
int createReview(...) {
    g_reviews[g_reviewCount++] = newReview;
    updateUserCreditProfile(reviewedUsername);  // 级联更新
    return newReview.reviewId;
}
```

2. **事务性操作**
```cpp
// 购买操作的事务性
bool purchaseItem(int itemId, const char* buyer) {
    // 1. 开始事务
    beginTransaction();
    
    // 2. 创建交易记录
    int transactionId = createTransaction(...);
    if (transactionId < 0) {
        rollback();
        return false;
    }
    
    // 3. 更新物品状态
    item->status = SOLD;
    if (saveItemsToFile(...) < 0) {
        rollback();
        return false;
    }
    
    // 4. 保存交易记录
    if (saveTransactionsToFile(...) < 0) {
        rollback();
        return false;
    }
    
    // 5. 提交事务
    commit();
    return true;
}
```

### 难点2：时间戳处理

**问题：**不同平台的 time_t 类型大小不同，如何保证跨平台兼容？

**解决方案：**

```cpp
// 统一使用 long long 存储时间戳
int saveTransactionsToFile(const char* filename) {
    fprintf(fp, "%lld", (long long)transaction->transactionTime);
}

int loadTransactionsFromFile(const char* filename) {
    long long tempTime = 0;
    sscanf(line, "...,%lld,...", &tempTime);
    transaction->transactionTime = (time_t)tempTime;
}
```

**跨平台兼容性：**
- Windows: time_t 通常是 64位
- Linux: time_t 通常是 64位
- 使用 long long 确保至少 64位

### 难点3：评分系统的公平性

**问题：**如何防止刷分和恶意评价？

**解决方案：**

1. **评价限制**
```cpp
// 只能对已完成的交易进行评价
bool canReview(int transactionId, const char* reviewer) {
    Transaction* t = findTransactionById(transactionId);
    if (t == NULL) return false;
    if (t->status != TRANSACTION_COMPLETED) return false;
    
    // 只有交易参与者可以评价
    if (strcmp(t->sellerUsername, reviewer) != 0 &&
        strcmp(t->buyerUsername, reviewer) != 0) {
        return false;
    }
    
    return true;
}
```

2. **防止重复评价**
```cpp
// 每个用户对每笔交易只能评价一次
for (int i = 0; i < g_reviewCount; i++) {
    if (g_reviews[i].transactionId == transactionId && 
        strcmp(g_reviews[i].reviewerUsername, reviewer) == 0) {
        return false;  // 已评价过
    }
}
```

3. **评价时效性**
```cpp
// 交易完成后30天内可以评价
bool isReviewTimeValid(time_t transactionTime) {
    time_t now = time(NULL);
    time_t diff = now - transactionTime;
    const time_t THIRTY_DAYS = 30 * 24 * 60 * 60;
    
    return diff <= THIRTY_DAYS;
}
```

### 难点4：性能优化

**问题：**随着数据量增长，查询和统计操作变慢。

**解决方案：**

1. **索引优化**
```cpp
// 为交易ID建立哈希表索引
typedef struct {
    int transactionId;
    int arrayIndex;
} TransactionIndex;

TransactionIndex g_transactionIndex[MAX_TRANSACTIONS];
int g_indexCount = 0;

// 建立索引
void buildTransactionIndex() {
    for (int i = 0; i < g_transactionCount; i++) {
        g_transactionIndex[i].transactionId = g_transactions[i].transactionId;
        g_transactionIndex[i].arrayIndex = i;
    }
    g_indexCount = g_transactionCount;
    
    // 排序索引（用于二分查找）
    qsort(g_transactionIndex, g_indexCount, 
          sizeof(TransactionIndex), compareTransactionId);
}

// 二分查找
Transaction* findTransactionByIdFast(int transactionId) {
    int left = 0, right = g_indexCount - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (g_transactionIndex[mid].transactionId == transactionId) {
            int index = g_transactionIndex[mid].arrayIndex;
            return &g_transactions[index];
        } else if (g_transactionIndex[mid].transactionId < transactionId) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return NULL;
}

// 时间复杂度：O(log n)
```

2. **缓存机制**
```cpp
// 缓存用户信誉档案，避免重复计算
typedef struct {
    char username[MAX_USERNAME_LEN];
    UserCreditProfile profile;
    time_t cacheTime;
    bool isDirty;  // 是否需要重新计算
} CreditProfileCache;

CreditProfileCache g_profileCache[MAX_USERS];

UserCreditProfile* getCreditProfile(const char* username) {
    // 1. 查找缓存
    for (int i = 0; i < MAX_USERS; i++) {
        if (strcmp(g_profileCache[i].username, username) == 0) {
            if (!g_profileCache[i].isDirty) {
                return &g_profileCache[i].profile;  // 返回缓存
            }
            break;
        }
    }
    
    // 2. 重新计算并缓存
    updateUserCreditProfile(username);
    // ... 更新缓存
    
    return &g_profileCache[i].profile;
}
```

3. **批量操作**
```cpp
// 批量更新信誉档案
void batchUpdateCreditProfiles(const char* usernames[], int count) {
    for (int i = 0; i < count; i++) {
        updateUserCreditProfile(usernames[i]);
    }
    
    // 一次性保存所有档案
    saveCreditProfilesToFile("credit_profiles.txt");
}
```

---

## 4.8 系统扩展性设计

### 4.8.1 信誉等级体系扩展

当前系统支持6个等级，如需扩展：

```cpp
// 扩展到10个等级
typedef enum {
    CREDIT_LEVEL_NEW = 0,           // 新手 (0-50)
    CREDIT_LEVEL_BRONZE_3 = 1,      // 青铜III (51-75)
    CREDIT_LEVEL_BRONZE_2 = 2,      // 青铜II (76-100)
    CREDIT_LEVEL_BRONZE_1 = 3,      // 青铜I (101-150)
    CREDIT_LEVEL_SILVER_3 = 4,      // 白银III (151-200)
    CREDIT_LEVEL_SILVER_2 = 5,      // 白银II (201-300)
    CREDIT_LEVEL_SILVER_1 = 6,      // 白银I (301-400)
    CREDIT_LEVEL_GOLD = 7,          // 黄金 (401-600)
    CREDIT_LEVEL_PLATINUM = 8,      // 铂金 (601-1000)
    CREDIT_LEVEL_DIAMOND = 9        // 钻石 (1001+)
} CreditLevel;

CreditLevel calculateCreditLevel(int creditScore) {
    if (creditScore <= 50) return CREDIT_LEVEL_NEW;
    if (creditScore <= 75) return CREDIT_LEVEL_BRONZE_3;
    if (creditScore <= 100) return CREDIT_LEVEL_BRONZE_2;
    // ... 更多等级
    return CREDIT_LEVEL_DIAMOND;
}
```

### 4.8.2 评分维度扩展

当前只有总体评分，可扩展为多维度评分：

```cpp
typedef struct {
    int reviewId;
    int transactionId;
    char reviewerUsername[50];
    char reviewedUsername[50];
    
    // 多维度评分
    RatingLevel overallRating;      // 总体评分
    RatingLevel communicationRating; // 沟通评分
    RatingLevel speedRating;        // 速度评分
    RatingLevel qualityRating;      // 质量评分
    
    char comment[200];
    time_t reviewTime;
    bool isSellerReview;
} MultiDimensionalReview;

// 计算加权平均分
float calculateWeightedRating(const MultiDimensionalReview* review) {
    return (review->overallRating * 0.4 +
            review->communicationRating * 0.2 +
            review->speedRating * 0.2 +
            review->qualityRating * 0.2);
}
```

---

## 小结

信用评价系统是整个平台的核心，实现了以下功能：

1. **交易管理**：完整的交易生命周期管理
2. **评价系统**：5星评分 + 文字评价
3. **信誉计算**：基于交易和评价的综合评分算法
4. **等级体系**：6级信誉等级，激励用户良好行为
5. **排行榜**：展示优秀用户，增强社区氛围
6. **数据持久化**：可靠的数据存储和加载

**关键技术：**
- 复杂的信誉分数计算算法
- 级联更新机制
- 数据一致性保证
- 时间戳处理
- 性能优化（索引、缓存）

**算法复杂度总结：**
- 创建交易：O(1)
- 查找交易：O(n)（可优化至O(log n)）
- 创建评价：O(n)
- 计算平均评分：O(m)
- 计算信誉分数：O(n + m)
- 更新信誉档案：O(n + m)
- 排行榜：O(k × n)（可优化至O(n log n)）

**系统特点：**
- 公平性：防止刷分和恶意评价
- 可扩展性：易于添加新等级和评分维度
- 高性能：支持索引和缓存优化
- 可靠性：数据一致性保证

---

**全系列完成！**

至此，我们已经完整讲解了校园二手交易系统的所有核心功能：
1. 登录注册系统
2. 主菜单与物品浏览
3. 物品发布与详情查看
4. 信用评价系统与交易管理

每个部分都包含详细的算法分析、代码实现和优化方案，可以直接用于课程设计报告！
