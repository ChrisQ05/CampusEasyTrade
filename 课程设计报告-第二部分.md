# 第二部分：主菜单系统与物品浏览功能

## 2.1 主菜单系统

### 功能概述
用户登录成功后进入主菜单界面，提供六个核心功能入口：
1. 浏览物品 - 查看所有在售商品
2. 搜索物品 - 按关键词搜索商品
3. 发布新物品 - 发布二手商品
4. 我的信誉档案 - 查看个人信誉信息
5. 交易历史 - 查看交易记录
6. 退出系统 - 退出登录

### 核心技术实现

**1. 主菜单界面绘制 (`drawMainMenu`)**

```cpp
void drawMainMenu() {
    BeginBatchDraw();
    
    // 设置背景色
    setbkcolor(RGB(236, 240, 241));
    cleardevice();
    
    // 绘制系统Logo
    settextcolor(RGB(142, 68, 173));
    settextstyle(40, 0, "Bauhaus 93");
    outtextxy(10, 10, "SimpTrade");
    
    // 绘制标题
    settextstyle(40, 0, "宋体");
    outtextxy(230, 100, "校园二手交易系统");
    
    // 绘制功能按钮（垂直排列）
    drawButton(300, 150, 200, 50, "浏览物品");
    drawButton(300, 210, 200, 50, "搜索物品");
    drawButton(300, 270, 200, 50, "发布新物品");
    drawButton(300, 330, 200, 50, "我的信誉档案");
    drawButton(300, 390, 200, 50, "交易历史");
    drawButton(300, 450, 200, 50, "退出系统");
    
    // 绘制装饰边框
    setlinecolor(RGB(142, 68, 173));
    setlinestyle(PS_SOLID, 3);
    rectangle(200, 80, 600, 600);
    
    EndBatchDraw();
}
```

**技术要点：**
- **统一的视觉风格**：使用相同的配色方案和按钮样式
- **垂直布局算法**：按钮Y坐标递增，间距为60像素
- **品牌一致性**：保持Logo和标题在所有界面的一致性

**2. 主菜单事件处理 (`handleMainMenuClick`)**

```cpp
void handleMainMenuClick(ExMessage msg) {
    if (msg.message == WM_LBUTTONDOWN) {
        // 浏览物品按钮 (300, 150, 200, 50)
        if (msg.x >= 300 && msg.x <= 500 && msg.y >= 150 && msg.y <= 200) {
            g_currentScreen = SCREEN_ITEM_LIST;
            printf("切换到物品列表界面。\n");
        }
        // 搜索物品按钮 (300, 210, 200, 50)
        else if (msg.x >= 300 && msg.x <= 500 && msg.y >= 210 && msg.y <= 260) {
            g_currentScreen = SCREEN_SEARCH_RESULT;
            printf("切换到搜索结果界面。\n");
        }
        // 发布新物品按钮 (300, 270, 200, 50)
        else if (msg.x >= 300 && msg.x <= 500 && msg.y >= 270 && msg.y <= 320) {
            g_currentScreen = SCREEN_ADD_ITEM;
            printf("切换到发布物品界面。\n");
        }
        // 我的信誉档案按钮 (300, 330, 200, 50)
        else if (msg.x >= 300 && msg.x <= 500 && msg.y >= 330 && msg.y <= 380) {
            g_currentScreen = SCREEN_CREDIT_PROFILE;
            printf("切换到信誉档案界面。\n");
        }
        // 交易历史按钮 (300, 390, 200, 50)
        else if (msg.x >= 300 && msg.x <= 500 && msg.y >= 390 && msg.y <= 440) {
            g_currentScreen = SCREEN_TRANSACTION_HISTORY;
            printf("切换到交易历史界面。\n");
        }
        // 退出系统按钮 (300, 450, 200, 50)
        else if (msg.x >= 300 && msg.x <= 500 && msg.y >= 450 && msg.y <= 500) {
            exit(0);  // 直接退出程序
        }
    }
}
```

**技术要点：**
- **if-else链式判断**：按顺序检测每个按钮的点击
- **坐标计算规律**：Y坐标 = 基准Y + 索引 × 间距
- **状态切换**：通过修改 `g_currentScreen` 实现界面跳转

---

## 2.2 物品列表浏览功能

### 功能概述
物品列表界面展示所有在售商品，支持分页浏览和点击查看详情。

### 核心数据结构

**1. 物品结构体 (`Item`)**

```cpp
typedef struct {
    int id;                                 // 物品唯一ID
    char name[MAX_NAME_LEN];                // 物品名称（最多50字符）
    char description[MAX_DESC_LEN];         // 物品描述（最多100字符）
    float price;                            // 价格
    ItemStatus status;                      // 物品状态（在售/已售出）
    char contactInfo[MAX_CONTACT_LEN];      // 联系方式（最多20字符）
    char publisher[MAX_USERNAME_LEN];       // 发布者用户名
} Item;
```

**2. 全局物品数组**

```cpp
Item g_items[MAX_ITEMS];    // 最多存储100件物品
int g_itemCount = 0;        // 当前物品数量
int g_itemListScrollOffset = 0;  // 列表滚动偏移量
```

### 核心算法实现

**1. 物品列表绘制 (`drawItemListScreen`)**

```cpp
#define ITEMS_PER_PAGE 12       // 每页显示12件物品
#define ITEM_ROW_HEIGHT 30      // 每行高度30像素
#define ITEM_LIST_START_X 50    // 列表起始X坐标
#define ITEM_LIST_START_Y 100   // 列表起始Y坐标

void drawItemListScreen() {
    BeginBatchDraw();
    setbkcolor(RGB(220, 240, 220));  // 浅绿色背景
    cleardevice();
    
    // 绘制标题
    settextcolor(RGB(50, 50, 150));
    settextstyle(36, 0, "微软雅黑");
    outtextxy(300, 30, "在售物品列表");
    
    // 绘制表头
    settextcolor(BLACK);
    settextstyle(20, 0, "宋体");
    outtextxy(ITEM_LIST_START_X, ITEM_LIST_START_Y, "ID");
    outtextxy(ITEM_LIST_START_X + 60, ITEM_LIST_START_Y, "名称");
    outtextxy(ITEM_LIST_START_X + 260, ITEM_LIST_START_Y, "价格");
    outtextxy(ITEM_LIST_START_X + 360, ITEM_LIST_START_Y, "状态");
    outtextxy(ITEM_LIST_START_X + 460, ITEM_LIST_START_Y, "联系方式");
    
    // 绘制表头分隔线
    line(ITEM_LIST_START_X, ITEM_LIST_START_Y + ITEM_ROW_HEIGHT,
         ITEM_LIST_START_X + 700, ITEM_LIST_START_Y + ITEM_ROW_HEIGHT);
    
    // === 核心算法：筛选在售物品 ===
    int availableItemCount = 0;
    int availableItemIndices[MAX_ITEMS];  // 存储在售物品的索引
    
    for (int i = 0; i < g_itemCount; i++) {
        if (g_items[i].status == ITEM_STATUS_AVAILABLE) {  // 只显示在售物品
            availableItemIndices[availableItemCount++] = i;
        }
    }
    
    // === 核心算法：滚动偏移量修正 ===
    // 确保偏移量在有效范围内
    if (g_itemListScrollOffset < 0) {
        g_itemListScrollOffset = 0;
    }
    
    // 计算最大偏移量
    int maxScrollOffset = (availableItemCount > ITEMS_PER_PAGE) 
                          ? (availableItemCount - ITEMS_PER_PAGE) 
                          : 0;
    if (g_itemListScrollOffset > maxScrollOffset) {
        g_itemListScrollOffset = maxScrollOffset;
    }
    
    // === 核心算法：分页显示 ===
    int currentY = ITEM_LIST_START_Y + ITEM_ROW_HEIGHT + 5;
    int displayedItems = 0;
    
    for (int k = 0; k < availableItemCount; k++) {
        // 只显示当前页的物品
        if (k >= g_itemListScrollOffset && displayedItems < ITEMS_PER_PAGE) {
            Item item = g_items[availableItemIndices[k]];
            
            // 绘制物品ID
            char idStr[10];
            sprintf_s(idStr, sizeof(idStr), "%d", item.id);
            outtextxy(ITEM_LIST_START_X, currentY, idStr);
            
            // 绘制物品名称
            outtextxy(ITEM_LIST_START_X + 60, currentY, item.name);
            
            // 绘制价格
            char priceStr[20];
            sprintf_s(priceStr, sizeof(priceStr), "%.2f", item.price);
            outtextxy(ITEM_LIST_START_X + 260, currentY, priceStr);
            
            // 绘制状态
            outtextxy(ITEM_LIST_START_X + 360, currentY, 
                     item.status ? "已售出" : "在售");
            
            // 绘制联系方式
            outtextxy(ITEM_LIST_START_X + 460, currentY, item.contactInfo);
            
            currentY += ITEM_ROW_HEIGHT;
            displayedItems++;
        }
    }
    
    // 绘制返回按钮
    drawButton(50, 550, 150, 40, "返回主菜单");
    
    // 绘制滚动按钮（仅在需要时显示）
    if (availableItemCount > ITEMS_PER_PAGE) {
        drawButton(700, ITEM_LIST_START_Y + ITEM_ROW_HEIGHT + 5, 50, 40, "▲");
        drawButton(700, currentY - ITEM_ROW_HEIGHT + 
                   (ITEMS_PER_PAGE * ITEM_ROW_HEIGHT) + 5, 50, 40, "▼");
    }
    
    EndBatchDraw();
}
```

**核心算法分析：**

**算法1：在售物品筛选**
```
输入：全局物品数组 g_items[MAX_ITEMS]
输出：在售物品索引数组 availableItemIndices[]

伪代码：
availableItemCount = 0
for i = 0 to g_itemCount - 1:
    if g_items[i].status == ITEM_STATUS_AVAILABLE:
        availableItemIndices[availableItemCount] = i
        availableItemCount++

时间复杂度：O(n)，n为物品总数
空间复杂度：O(n)，需要额外数组存储索引
```

**算法2：分页显示算法**
```
输入：
  - availableItemIndices: 在售物品索引数组
  - g_itemListScrollOffset: 当前页起始索引
  - ITEMS_PER_PAGE: 每页显示数量

输出：当前页显示的物品

伪代码：
displayedItems = 0
for k = 0 to availableItemCount - 1:
    if k >= g_itemListScrollOffset AND displayedItems < ITEMS_PER_PAGE:
        item = g_items[availableItemIndices[k]]
        绘制item
        displayedItems++

时间复杂度：O(n)，最坏情况遍历所有在售物品
优化方案：直接从 g_itemListScrollOffset 开始遍历，复杂度降至 O(ITEMS_PER_PAGE)
```

**优化后的分页算法：**
```cpp
// 优化版本：直接计算起始和结束索引
int startIndex = g_itemListScrollOffset;
int endIndex = min(startIndex + ITEMS_PER_PAGE, availableItemCount);

for (int k = startIndex; k < endIndex; k++) {
    Item item = g_items[availableItemIndices[k]];
    // 绘制物品...
}
```

**算法3：滚动偏移量边界检查**
```
输入：
  - g_itemListScrollOffset: 当前偏移量
  - availableItemCount: 在售物品总数
  - ITEMS_PER_PAGE: 每页显示数量

输出：修正后的偏移量

伪代码：
// 下界检查
if g_itemListScrollOffset < 0:
    g_itemListScrollOffset = 0

// 上界检查
maxScrollOffset = max(0, availableItemCount - ITEMS_PER_PAGE)
if g_itemListScrollOffset > maxScrollOffset:
    g_itemListScrollOffset = maxScrollOffset

时间复杂度：O(1)
```

---

**2. 物品列表事件处理 (`handleItemListClick`)**

```cpp
void handleItemListClick(ExMessage msg) {
    if (msg.message == WM_LBUTTONDOWN) {
        // === 1. 返回主菜单按钮 ===
        if (msg.x >= 50 && msg.x <= 200 && msg.y >= 550 && msg.y <= 590) {
            g_currentScreen = SCREEN_MAIN_MENU;
            g_itemListScrollOffset = 0;  // 重置滚动位置
            return;
        }
        
        // === 2. 计算在售物品数量 ===
        int availableItemCount = 0;
        for (int i = 0; i < g_itemCount; i++) {
            if (g_items[i].status == ITEM_STATUS_AVAILABLE) {
                availableItemCount++;
            }
        }
        
        // === 3. 向上滚动按钮 ===
        if (availableItemCount > ITEMS_PER_PAGE &&
            msg.x >= 700 && msg.x <= 750 &&
            msg.y >= ITEM_LIST_START_Y + ITEM_ROW_HEIGHT + 5 && 
            msg.y <= ITEM_LIST_START_Y + ITEM_ROW_HEIGHT + 45) {
            
            if (g_itemListScrollOffset > 0) {
                g_itemListScrollOffset--;  // 向上滚动一行
            }
            return;
        }
        
        // === 4. 向下滚动按钮 ===
        int lastItemDisplayedY = ITEM_LIST_START_Y + ITEM_ROW_HEIGHT + 5 + 
                                 (ITEMS_PER_PAGE - 1) * ITEM_ROW_HEIGHT;
        if (availableItemCount > ITEMS_PER_PAGE &&
            msg.x >= 700 && msg.x <= 750 &&
            msg.y >= lastItemDisplayedY + (ITEMS_PER_PAGE * ITEM_ROW_HEIGHT) + 5 && 
            msg.y <= lastItemDisplayedY + (ITEMS_PER_PAGE * ITEM_ROW_HEIGHT) + 45) {
            
            int maxScrollOffset = availableItemCount - ITEMS_PER_PAGE;
            if (g_itemListScrollOffset < maxScrollOffset) {
                g_itemListScrollOffset++;  // 向下滚动一行
            }
            return;
        }
        
        // === 5. 点击列表行进入详情 ===
        int listStartX = ITEM_LIST_START_X;
        int listEndX = ITEM_LIST_START_X + 700;
        int listStartY = ITEM_LIST_START_Y + ITEM_ROW_HEIGHT + 5;
        int listEndY = listStartY + ITEMS_PER_PAGE * ITEM_ROW_HEIGHT;
        
        if (msg.x >= listStartX && msg.x <= listEndX && 
            msg.y >= listStartY && msg.y <= listEndY) {
            
            // 计算点击的是第几行（0-based）
            int rowIndexOnPage = (msg.y - listStartY) / ITEM_ROW_HEIGHT;
            
            if (rowIndexOnPage >= 0 && rowIndexOnPage < ITEMS_PER_PAGE) {
                // 计算实际物品索引
                int targetIndex = g_itemListScrollOffset + rowIndexOnPage;
                
                // 查找对应的物品
                int currentAvailable = 0;
                int chosenItemIdx = -1;
                
                for (int i = 0; i < g_itemCount; i++) {
                    if (g_items[i].status == ITEM_STATUS_AVAILABLE) {
                        if (currentAvailable == targetIndex) {
                            chosenItemIdx = i;
                            break;
                        }
                        currentAvailable++;
                    }
                }
                
                // 跳转到物品详情页
                if (chosenItemIdx != -1) {
                    g_currentItemId = g_items[chosenItemIdx].id;
                    g_currentScreen = SCREEN_ITEM_DETAIL;
                    printf("进入物品详情，ID: %d\n", g_currentItemId);
                    return;
                }
            }
        }
    }
}
```

**核心算法：点击行转物品索引**

```
输入：
  - mouseY: 鼠标Y坐标
  - listStartY: 列表起始Y坐标
  - ITEM_ROW_HEIGHT: 行高
  - g_itemListScrollOffset: 滚动偏移量

输出：被点击物品的全局索引

步骤：
1. 计算页内行索引：
   rowIndexOnPage = (mouseY - listStartY) / ITEM_ROW_HEIGHT

2. 计算在售物品中的索引：
   targetIndex = g_itemListScrollOffset + rowIndexOnPage

3. 映射到全局物品数组：
   遍历 g_items，找到第 targetIndex 个在售物品

时间复杂度：O(n)，n为物品总数
优化方案：维护在售物品索引数组，直接查找，复杂度降至O(1)
```

**优化后的算法：**

```cpp
// 在绘制时就维护索引数组
static int g_availableItemIndices[MAX_ITEMS];
static int g_availableItemCount = 0;

// 点击时直接使用
int targetIndex = g_itemListScrollOffset + rowIndexOnPage;
if (targetIndex < g_availableItemCount) {
    int chosenItemIdx = g_availableItemIndices[targetIndex];
    g_currentItemId = g_items[chosenItemIdx].id;
    g_currentScreen = SCREEN_ITEM_DETAIL;
}
```

---

### 技术难点与解决方案

**难点1：滚动列表的实现**

**问题：**如何在固定区域内显示大量数据，并支持滚动浏览？

**解决方案：**
1. 使用偏移量 `g_itemListScrollOffset` 记录当前显示的起始位置
2. 每次只绘制可见区域的数据（12条）
3. 通过上下按钮修改偏移量，触发重绘

**难点2：状态筛选与索引映射**

**问题：**全局数组包含已售出物品，但列表只显示在售物品，如何正确映射？

**解决方案：**
1. 创建临时索引数组 `availableItemIndices[]`
2. 遍历全局数组，筛选在售物品，记录索引
3. 显示和点击时都使用索引数组进行映射

**难点3：边界条件处理**

**问题：**滚动到顶部或底部时如何防止越界？

**解决方案：**
```cpp
// 上界检查
if (g_itemListScrollOffset < 0) {
    g_itemListScrollOffset = 0;
}

// 下界检查
int maxScrollOffset = max(0, availableItemCount - ITEMS_PER_PAGE);
if (g_itemListScrollOffset > maxScrollOffset) {
    g_itemListScrollOffset = maxScrollOffset;
}
```

---

## 小结

主菜单和物品浏览系统实现了以下核心功能：

1. **主菜单导航**：提供清晰的功能入口，支持快速跳转
2. **物品列表展示**：表格形式展示物品信息，一目了然
3. **分页浏览**：支持大量数据的分页显示，提升用户体验
4. **状态筛选**：自动过滤已售出物品，只显示在售商品
5. **交互反馈**：点击行进入详情，滚动按钮控制翻页

**关键技术：**
- 分页显示算法
- 滚动偏移量管理
- 状态筛选与索引映射
- 鼠标坐标到数据索引的转换
- 边界条件处理

**算法复杂度总结：**
- 物品筛选：O(n)
- 分页显示：O(ITEMS_PER_PAGE) ≈ O(1)
- 点击定位：O(n)（可优化至O(1)）
- 滚动控制：O(1)

---

**下一部分预告：物品发布与详情查看功能**
