# 第五部分：管理员功能模块

## 5.1 管理员系统概述

### 功能定位
管理员系统是平台的后台管理模块，提供对用户和物品的全面管理能力，确保平台的正常运行和秩序维护。

### 核心功能
1. **管理员登录** - 独立的管理员登录入口
2. **物品管理** - 查看、删除所有物品
3. **用户管理** - 查看、删除用户账号
4. **权限控制** - 基于用户类型的访问控制

### 用户类型枚举

```cpp
typedef enum {
    USER_TYPE_NORMAL = 0,  // 普通用户
    USER_TYPE_ADMIN = 1    // 管理员
} UserType;
```

### 用户结构体

```cpp
typedef struct {
    char username[MAX_USERNAME_LEN];
    char password[MAX_PASSWORD_LEN];
    UserType type;            // 用户类型
    int publishedItems;       // 已发布物品数
    int ecoPoints;            // 环保积分
    int creditPoints;         // 信誉积分
} User;
```

---

## 5.2 管理员登录系统

### 5.2.1 管理员登录界面

```cpp
void drawAdminLoginScreen() {
    BeginBatchDraw();
    setbkcolor(RGB(245, 245, 255));  // 浅蓝色背景
    cleardevice();
    
    // 绘制标题（使用不同颜色区分管理员界面）
    settextcolor(RGB(150, 50, 50));  // 深红色，表示管理员
    settextstyle(36, 0, "微软雅黑");
    outtextxy(280, 80, "管理员登录");
    
    settextcolor(BLACK);
    settextstyle(24, 0, "宋体");
    
    // 用户名输入框
    outtextxy(LOGIN_LABEL_START_X, 200, "用户名:");
    drawInputField(LOGIN_INPUT_START_X, 200, LOGIN_INPUT_WIDTH, 
                   LOGIN_FIELD_HEIGHT, g_loginUsernameBuffer, 
                   g_activeInputBox == 11);
    
    // 密码输入框
    outtextxy(LOGIN_LABEL_START_X, 200 + LOGIN_FIELD_SPACING, "密码:");
    drawInputField(LOGIN_INPUT_START_X, 200 + LOGIN_FIELD_SPACING, 
                   LOGIN_INPUT_WIDTH, LOGIN_FIELD_HEIGHT, 
                   g_loginPasswordBuffer, g_activeInputBox == 12);
    
    // 绘制按钮
    drawButton(250, 400, 120, 50, "登录");
    drawButton(430, 400, 120, 50, "返回");
    
    EndBatchDraw();
}
```

**界面设计要点：**
- **视觉区分**：使用深红色标题，与普通用户登录界面区分
- **安全提示**：可添加"仅限管理员使用"的警告文字
- **布局一致**：保持与普通登录界面相同的布局，降低学习成本

### 5.2.2 管理员身份验证

```cpp
void handleAdminLoginClick(ExMessage msg) {
    if (msg.message == WM_LBUTTONDOWN) {
        // 登录按钮
        if (msg.x >= 250 && msg.x <= 370 && msg.y >= 400 && msg.y <= 450) {
            saveInputBufferContent();
            
            char* inputUsername = g_loginUsernameBuffer;
            char* inputPassword = g_loginPasswordBuffer;
            
            // === 1. 输入验证 ===
            if (strlen(inputUsername) == 0 || strlen(inputPassword) == 0) {
                printf("用户名或密码不能为空！\n");
                return;
            }
            
            // === 2. 管理员身份验证 ===
            bool loginSuccess = false;
            for (int i = 0; i < g_userCount; i++) {
                // 用户名匹配
                if (strcmp(g_users[i].username, inputUsername) == 0) {
                    // 密码匹配
                    if (strcmp(g_users[i].password, inputPassword) == 0) {
                        // === 关键：检查用户类型 ===
                        if (g_users[i].type == USER_TYPE_ADMIN) {
                            printf("管理员登录成功！\n");
                            g_currentUser = &g_users[i];
                            loginSuccess = true;
                            break;
                        } else {
                            printf("错误：该账号不是管理员账号！\n");
                            return;  // 非管理员账号，拒绝登录
                        }
                    }
                }
            }
            
            // === 3. 登录结果处理 ===
            if (loginSuccess) {
                printf("欢迎管理员 %s！\n", g_currentUser->username);
                g_currentScreen = SCREEN_ADMIN_MENU;  // 进入管理员菜单
            } else {
                printf("用户名或密码错误，或该账号不是管理员！\n");
            }
            
            g_activeInputBox = 0;
            g_inputBuffer[0] = '\0';
            return;
        }
        
        // 返回按钮
        if (msg.x >= 430 && msg.x <= 550 && msg.y >= 400 && msg.y <= 450) {
            saveInputBufferContent();
            g_currentScreen = SCREEN_LOGIN_REGISTER_ADMIN_ENTRY;
            g_activeInputBox = 0;
            g_inputBuffer[0] = '\0';
            return;
        }
        
        // 输入框焦点切换（与普通登录相同）
        // ... 省略焦点切换代码
    }
}
```

**核心算法：三重验证**

```
输入：用户名，密码
输出：登录成功/失败

验证流程：
1. 非空验证
   if username is empty OR password is empty:
       return FAIL("输入不能为空")

2. 用户名密码验证
   user = findUserByUsername(username)
   if user == NULL:
       return FAIL("用户名不存在")
   
   if user.password != password:
       return FAIL("密码错误")

3. 管理员权限验证（关键步骤）
   if user.type != USER_TYPE_ADMIN:
       return FAIL("非管理员账号")

4. 登录成功
   g_currentUser = user
   g_currentScreen = ADMIN_MENU
   return SUCCESS

时间复杂度：O(n)，n为用户总数
空间复杂度：O(1)
```

**安全性分析：**

| 验证层次 | 作用 | 防御攻击类型 |
|---------|------|-------------|
| 非空验证 | 防止空输入 | 输入验证绕过 |
| 用户名密码验证 | 身份认证 | 未授权访问 |
| 管理员类型验证 | 权限控制 | 权限提升攻击 |

**潜在安全问题与改进：**

```cpp
// 问题1：密码明文存储
// 改进：使用哈希加密
#include <openssl/sha.h>

void hashPassword(const char* password, char* hash) {
    unsigned char digest[SHA256_DIGEST_LENGTH];
    SHA256((unsigned char*)password, strlen(password), digest);
    
    for (int i = 0; i < SHA256_DIGEST_LENGTH; i++) {
        sprintf(hash + (i * 2), "%02x", digest[i]);
    }
    hash[64] = '\0';
}

// 问题2：登录失败信息过于详细
// 改进：统一错误提示
if (!loginSuccess) {
    printf("登录失败！\n");  // 不透露具体原因
}

// 问题3：无登录尝试次数限制
// 改进：添加登录失败计数
static int loginAttempts = 0;
const int MAX_ATTEMPTS = 5;

if (!loginSuccess) {
    loginAttempts++;
    if (loginAttempts >= MAX_ATTEMPTS) {
        printf("登录失败次数过多，账号已锁定！\n");
        // 锁定账号或延迟登录
    }
}
```

---

## 5.3 管理员主菜单

### 5.3.1 主菜单界面

```cpp
void drawAdminMenuScreen() {
    BeginBatchDraw();
    setbkcolor(RGB(200, 220, 250));  // 偏深的蓝色背景，与普通用户界面区分
    cleardevice();
    
    // 绘制标题
    settextcolor(RGB(30, 30, 80));
    settextstyle(40, 0, "微软雅黑");
    outtextxy(280, 80, "管理员控制台");
    
    // 绘制功能按钮
    drawButton(280, 200, 240, 60, "物品管理");
    drawButton(280, 280, 240, 60, "用户管理");
    drawButton(280, 360, 240, 60, "退出登录");
    
    EndBatchDraw();
}
```

**设计特点：**
- **配色区分**：使用深蓝色背景，与普通用户的浅色背景区分
- **功能聚焦**：只提供核心管理功能，界面简洁
- **快速访问**：大按钮设计，便于快速操作

### 5.3.2 主菜单事件处理

```cpp
void handleAdminMenuClick(ExMessage msg) {
    if (msg.message == WM_LBUTTONDOWN) {
        // 物品管理按钮
        if (msg.x >= 280 && msg.x <= 520 && msg.y >= 200 && msg.y <= 260) {
            g_currentScreen = SCREEN_ADMIN_ITEM_LIST;
            printf("进入物品管理界面\n");
            return;
        }
        
        // 用户管理按钮
        if (msg.x >= 280 && msg.x <= 520 && msg.y >= 280 && msg.y <= 340) {
            g_currentScreen = SCREEN_ADMIN_USER_LIST;
            g_userListScrollOffset = 0;  // 重置滚动位置
            printf("进入用户管理界面\n");
            return;
        }
        
        // 退出登录按钮
        if (msg.x >= 280 && msg.x <= 520 && msg.y >= 360 && msg.y <= 420) {
            g_currentScreen = SCREEN_LOGIN_REGISTER_ADMIN_ENTRY;
            g_currentUser = NULL;  // 清除当前用户
            printf("管理员已退出登录\n");
            return;
        }
    }
}
```

**技术要点：**
- **状态清理**：退出登录时清除 `g_currentUser`，防止权限残留
- **滚动重置**：进入列表界面时重置滚动偏移量
- **日志记录**：打印操作日志，便于调试和审计

---

## 5.4 物品管理功能

### 5.4.1 管理员物品列表界面

```cpp
#define ADMIN_ITEMS_PER_PAGE 10  // 管理员界面每页显示更多物品

void drawAdminItemListScreen() {
    BeginBatchDraw();
    setbkcolor(RGB(220, 240, 255));  // 浅蓝色背景
    cleardevice();
    
    // 绘制标题
    settextcolor(RGB(50, 50, 150));
    settextstyle(36, 0, "微软雅黑");
    outtextxy(280, 30, "物品管理");
    
    settextcolor(BLACK);
    settextstyle(20, 0, "宋体");
    
    // 绘制表头（比普通用户多一列"发布者"）
    outtextxy(50, 100, "ID");
    outtextxy(110, 100, "名称");
    outtextxy(310, 100, "价格");
    outtextxy(410, 100, "状态");
    outtextxy(510, 100, "发布者");
    outtextxy(610, 100, "操作");
    line(50, 130, 750, 130);
    
    // 绘制物品列表
    int currentY = 140;
    int displayedItems = 0;
    
    // 滚动偏移量修正
    if (g_itemListScrollOffset < 0) {
        g_itemListScrollOffset = 0;
    }
    int maxScrollOffset = (g_itemCount > ADMIN_ITEMS_PER_PAGE) 
                          ? (g_itemCount - ADMIN_ITEMS_PER_PAGE) 
                          : 0;
    if (g_itemListScrollOffset > maxScrollOffset) {
        g_itemListScrollOffset = maxScrollOffset;
    }
    
    // 显示物品（管理员可以看到所有物品，包括已售出的）
    for (int i = g_itemListScrollOffset; 
         i < g_itemCount && displayedItems < ADMIN_ITEMS_PER_PAGE; 
         i++) {
        
        Item* item = &g_items[i];
        
        // ID
        char idStr[10];
        sprintf_s(idStr, sizeof(idStr), "%d", item->id);
        outtextxy(50, currentY, idStr);
        
        // 名称（截断显示）
        char nameStr[30];
        strncpy_s(nameStr, sizeof(nameStr), item->name, 20);
        outtextxy(110, currentY, nameStr);
        
        // 价格
        char priceStr[20];
        sprintf_s(priceStr, sizeof(priceStr), "%.2f", item->price);
        outtextxy(310, currentY, priceStr);
        
        // 状态
        outtextxy(410, currentY, 
                 item->status == ITEM_STATUS_AVAILABLE ? "在售" : "已售出");
        
        // 发布者
        outtextxy(510, currentY, item->publisher);
        
        // 删除按钮
        drawButton(610, currentY - 5, 80, 25, "删除");
        
        currentY += 35;
        displayedItems++;
    }
    
    // 底部按钮
    drawButton(50, 550, 150, 40, "返回菜单");
    
    // 滚动按钮
    if (g_itemCount > ADMIN_ITEMS_PER_PAGE) {
        drawButton(700, 140, 50, 40, "▲");
        drawButton(700, 500, 50, 40, "▼");
    }
    
    // 统计信息
    char statsStr[100];
    sprintf_s(statsStr, sizeof(statsStr), 
             "总物品数: %d | 在售: %d | 已售出: %d", 
             g_itemCount, 
             countItemsByStatus(ITEM_STATUS_AVAILABLE),
             countItemsByStatus(ITEM_STATUS_SOLD));
    settextstyle(18, 0, "宋体");
    outtextxy(50, 600, statsStr);
    
    EndBatchDraw();
}
```


**辅助函数：统计物品数量**

```cpp
int countItemsByStatus(ItemStatus status) {
    int count = 0;
    for (int i = 0; i < g_itemCount; i++) {
        if (g_items[i].status == status) {
            count++;
        }
    }
    return count;
}
```

**时间复杂度**：O(n)，n为物品总数

### 5.4.2 删除物品功能

```cpp
void handleAdminItemListClick(ExMessage msg) {
    if (msg.message == WM_LBUTTONDOWN) {
        // 返回菜单按钮
        if (msg.x >= 50 && msg.x <= 200 && msg.y >= 550 && msg.y <= 590) {
            g_currentScreen = SCREEN_ADMIN_MENU;
            g_itemListScrollOffset = 0;
            return;
        }
        
        // 滚动按钮处理
        if (g_itemCount > ADMIN_ITEMS_PER_PAGE) {
            // 向上滚动
            if (msg.x >= 700 && msg.x <= 750 && msg.y >= 140 && msg.y <= 180) {
                if (g_itemListScrollOffset > 0) {
                    g_itemListScrollOffset--;
                }
                return;
            }
            // 向下滚动
            if (msg.x >= 700 && msg.x <= 750 && msg.y >= 500 && msg.y <= 540) {
                int maxScrollOffset = g_itemCount - ADMIN_ITEMS_PER_PAGE;
                if (g_itemListScrollOffset < maxScrollOffset) {
                    g_itemListScrollOffset++;
                }
                return;
            }
        }
        
        // === 删除按钮点击检测 ===
        int currentY = 140;
        for (int i = g_itemListScrollOffset; 
             i < g_itemCount && i < g_itemListScrollOffset + ADMIN_ITEMS_PER_PAGE; 
             i++) {
            
            // 检测删除按钮区域
            if (msg.x >= 610 && msg.x <= 690 && 
                msg.y >= currentY - 5 && msg.y <= currentY + 20) {
                
                // 确认删除
                printf("准备删除物品 ID: %d, 名称: %s\n", 
                       g_items[i].id, g_items[i].name);
                
                // 调用删除函数
                deleteItemById(g_items[i].id);
                
                // 保存到文件
                saveItemsToFile("items.txt");
                
                printf("物品已删除！\n");
                
                // 调整滚动偏移量（如果删除后列表变短）
                if (g_itemListScrollOffset > 0 && 
                    g_itemListScrollOffset >= g_itemCount - ADMIN_ITEMS_PER_PAGE) {
                    g_itemListScrollOffset--;
                }
                
                return;
            }
            
            currentY += 35;
        }
    }
}
```

**核心算法：删除物品**

```cpp
void deleteItemById(int id) {
    int foundIndex = -1;
    
    // 1. 查找物品索引
    for (int i = 0; i < g_itemCount; i++) {
        if (g_items[i].id == id) {
            foundIndex = i;
            break;
        }
    }
    
    if (foundIndex == -1) {
        printf("未找到物品 ID: %d\n", id);
        return;
    }
    
    // 2. 移动后续元素（覆盖删除）
    for (int i = foundIndex; i < g_itemCount - 1; i++) {
        g_items[i] = g_items[i + 1];
    }
    
    // 3. 减少计数
    g_itemCount--;
    
    printf("物品 ID: %d 已成功删除！\n", id);
}
```

**算法分析：**
```
输入：物品ID
输出：删除成功/失败

步骤：
1. 线性查找
   for i = 0 to g_itemCount - 1:
       if g_items[i].id == id:
           foundIndex = i
           break

2. 元素移动（覆盖删除）
   for i = foundIndex to g_itemCount - 2:
       g_items[i] = g_items[i + 1]

3. 更新计数
   g_itemCount--

时间复杂度：
- 查找：O(n)
- 移动：O(n)
- 总计：O(n)

空间复杂度：O(1)

优化方案：
1. 使用链表：删除操作O(1)
2. 标记删除：不实际删除，只标记为已删除
3. 延迟删除：批量删除，减少移动次数
```

**标记删除优化：**

```cpp
// 方案：添加 isDeleted 字段
typedef struct {
    int id;
    char name[MAX_NAME_LEN];
    // ... 其他字段
    bool isDeleted;  // 是否已删除
} Item;

// 删除操作变为O(1)
void deleteItemByIdFast(int id) {
    Item* item = findItemById(id);
    if (item != NULL) {
        item->isDeleted = true;  // 标记删除
    }
}

// 查询时过滤已删除项
void displayItems() {
    for (int i = 0; i < g_itemCount; i++) {
        if (!g_items[i].isDeleted) {  // 跳过已删除
            // 显示物品
        }
    }
}

// 定期清理
void compactItems() {
    int writeIndex = 0;
    for (int i = 0; i < g_itemCount; i++) {
        if (!g_items[i].isDeleted) {
            g_items[writeIndex++] = g_items[i];
        }
    }
    g_itemCount = writeIndex;
}
```

---

## 5.5 用户管理功能

### 5.5.1 用户列表界面

```cpp
#define USERS_PER_PAGE 8  // 每页显示8个用户

void drawAdminUserListScreen() {
    BeginBatchDraw();
    setbkcolor(RGB(230, 250, 240));  // 浅绿色背景
    cleardevice();
    
    // 绘制标题
    settextcolor(RGB(50, 150, 50));
    settextstyle(36, 0, "微软雅黑");
    outtextxy(280, 30, "用户管理");
    
    settextcolor(BLACK);
    settextstyle(20, 0, "宋体");
    
    // 绘制表头
    outtextxy(50, 100, "用户名");
    outtextxy(200, 100, "类型");
    outtextxy(300, 100, "发布物品");
    outtextxy(420, 100, "信誉分数");
    outtextxy(550, 100, "操作");
    line(50, 130, 700, 130);
    
    // 滚动偏移量修正
    if (g_userListScrollOffset < 0) {
        g_userListScrollOffset = 0;
    }
    int maxScrollOffset = (g_userCount > USERS_PER_PAGE) 
                          ? (g_userCount - USERS_PER_PAGE) 
                          : 0;
    if (g_userListScrollOffset > maxScrollOffset) {
        g_userListScrollOffset = maxScrollOffset;
    }
    
    // 绘制用户列表
    int currentY = 140;
    int displayedUsers = 0;
    
    for (int i = g_userListScrollOffset; 
         i < g_userCount && displayedUsers < USERS_PER_PAGE; 
         i++) {
        
        User* user = &g_users[i];
        
        // 用户名
        outtextxy(50, currentY, user->username);
        
        // 用户类型
        outtextxy(200, currentY, 
                 user->type == USER_TYPE_ADMIN ? "管理员" : "普通用户");
        
        // 发布物品数
        char itemsStr[20];
        sprintf_s(itemsStr, sizeof(itemsStr), "%d", user->publishedItems);
        outtextxy(300, currentY, itemsStr);
        
        // 信誉分数
        char creditStr[20];
        sprintf_s(creditStr, sizeof(creditStr), "%d", user->creditPoints);
        outtextxy(420, currentY, creditStr);
        
        // 删除按钮（管理员账号不能删除）
        if (user->type != USER_TYPE_ADMIN) {
            drawButton(550, currentY - 5, 80, 25, "删除");
        } else {
            settextcolor(LIGHTGRAY);
            outtextxy(550, currentY, "不可删除");
            settextcolor(BLACK);
        }
        
        currentY += 40;
        displayedUsers++;
    }
    
    // 底部按钮
    drawButton(50, 550, 150, 40, "返回菜单");
    
    // 滚动按钮
    if (g_userCount > USERS_PER_PAGE) {
        drawButton(700, 140, 50, 40, "▲");
        drawButton(700, 500, 50, 40, "▼");
    }
    
    // 统计信息
    char statsStr[100];
    sprintf_s(statsStr, sizeof(statsStr), 
             "总用户数: %d | 管理员: %d | 普通用户: %d", 
             g_userCount, 
             countAdminUsers(),
             g_userCount - countAdminUsers());
    settextstyle(18, 0, "宋体");
    outtextxy(50, 600, statsStr);
    
    EndBatchDraw();
}
```

**辅助函数：统计管理员数量**

```cpp
int countAdminUsers() {
    int adminCount = 0;
    for (int i = 0; i < g_userCount; i++) {
        if (g_users[i].type == USER_TYPE_ADMIN) {
            adminCount++;
        }
    }
    return adminCount;
}
```

### 5.5.2 删除用户功能

```cpp
void handleAdminUserListClick(ExMessage msg) {
    if (msg.message == WM_LBUTTONDOWN) {
        // 返回菜单按钮
        if (msg.x >= 50 && msg.x <= 200 && msg.y >= 550 && msg.y <= 590) {
            g_currentScreen = SCREEN_ADMIN_MENU;
            g_userListScrollOffset = 0;
            return;
        }
        
        // 滚动按钮处理（与物品列表类似）
        // ... 省略滚动代码
        
        // === 删除按钮点击检测 ===
        int currentY = 140;
        for (int i = g_userListScrollOffset; 
             i < g_userCount && i < g_userListScrollOffset + USERS_PER_PAGE; 
             i++) {
            
            User* user = &g_users[i];
            
            // 只有普通用户可以删除
            if (user->type != USER_TYPE_ADMIN) {
                if (msg.x >= 550 && msg.x <= 630 && 
                    msg.y >= currentY - 5 && msg.y <= currentY + 20) {
                    
                    printf("准备删除用户: %s\n", user->username);
                    
                    // === 安全检查 ===
                    // 1. 检查是否是最后一个管理员
                    if (user->type == USER_TYPE_ADMIN && countAdminUsers() <= 1) {
                        printf("错误：不能删除最后一个管理员账号！\n");
                        return;
                    }
                    
                    // 2. 检查是否是当前登录用户
                    if (g_currentUser != NULL && 
                        strcmp(user->username, g_currentUser->username) == 0) {
                        printf("错误：不能删除当前登录的账号！\n");
                        return;
                    }
                    
                    // 3. 执行删除
                    deleteUserByUsername(user->username);
                    
                    // 4. 保存到文件
                    saveUsersToFile("users.txt");
                    
                    printf("用户已删除！\n");
                    
                    // 5. 调整滚动偏移量
                    if (g_userListScrollOffset > 0 && 
                        g_userListScrollOffset >= g_userCount - USERS_PER_PAGE) {
                        g_userListScrollOffset--;
                    }
                    
                    return;
                }
            }
            
            currentY += 40;
        }
    }
}
```

**核心算法：删除用户**

```cpp
void deleteUserByUsername(const char* username) {
    int foundIndex = -1;
    
    // 1. 查找用户索引
    for (int i = 0; i < g_userCount; i++) {
        if (strcmp(g_users[i].username, username) == 0) {
            foundIndex = i;
            break;
        }
    }
    
    if (foundIndex == -1) {
        printf("未找到用户: %s\n", username);
        return;
    }
    
    // 2. 移动后续元素
    for (int i = foundIndex; i < g_userCount - 1; i++) {
        g_users[i] = g_users[i + 1];
    }
    
    // 3. 减少计数
    g_userCount--;
    
    printf("用户账号: %s 已成功删除。\n", username);
}
```

**安全检查流程：**

```
输入：用户名
输出：删除成功/失败

安全检查：
1. 管理员保护
   if user.type == ADMIN AND countAdminUsers() <= 1:
       return FAIL("不能删除最后一个管理员")

2. 自我保护
   if user.username == currentUser.username:
       return FAIL("不能删除当前登录账号")

3. 关联数据检查（可选）
   if user.publishedItems > 0:
       // 选项A：禁止删除
       return FAIL("该用户还有未处理的物品")
       
       // 选项B：级联删除
       deleteUserItems(user.username)
       deleteUserTransactions(user.username)
       deleteUserReviews(user.username)

4. 执行删除
   deleteUserByUsername(username)
   saveUsersToFile()

时间复杂度：O(n)
```


---

## 5.6 权限控制系统

### 5.6.1 基于角色的访问控制 (RBAC)

**权限矩阵：**

| 功能 | 普通用户 | 管理员 |
|------|---------|--------|
| 浏览物品 | ? | ? |
| 发布物品 | ? | ? |
| 购买物品 | ? | ? |
| 删除自己的物品 | ? | ? |
| 删除他人的物品 | ? | ? |
| 查看所有用户 | ? | ? |
| 删除用户 | ? | ? |
| 访问管理后台 | ? | ? |

**权限检查函数：**

```cpp
// 检查是否有管理员权限
bool isAdmin() {
    return (g_currentUser != NULL && 
            g_currentUser->type == USER_TYPE_ADMIN);
}

// 检查是否有删除物品的权限
bool canDeleteItem(int itemId) {
    if (g_currentUser == NULL) {
        return false;
    }
    
    // 管理员可以删除任何物品
    if (g_currentUser->type == USER_TYPE_ADMIN) {
        return true;
    }
    
    // 普通用户只能删除自己的物品
    Item* item = findItemById(itemId);
    if (item != NULL && 
        strcmp(item->publisher, g_currentUser->username) == 0) {
        return true;
    }
    
    return false;
}

// 检查是否有删除用户的权限
bool canDeleteUser(const char* username) {
    if (g_currentUser == NULL) {
        return false;
    }
    
    // 只有管理员可以删除用户
    if (g_currentUser->type != USER_TYPE_ADMIN) {
        return false;
    }
    
    // 不能删除自己
    if (strcmp(g_currentUser->username, username) == 0) {
        return false;
    }
    
    // 查找目标用户
    User* targetUser = findUserByUsername(username);
    if (targetUser == NULL) {
        return false;
    }
    
    // 不能删除最后一个管理员
    if (targetUser->type == USER_TYPE_ADMIN && countAdminUsers() <= 1) {
        return false;
    }
    
    return true;
}
```

**使用示例：**

```cpp
// 在删除操作前检查权限
void handleDeleteItemClick(int itemId) {
    if (!canDeleteItem(itemId)) {
        printf("错误：您没有权限删除此物品！\n");
        return;
    }
    
    deleteItemById(itemId);
    saveItemsToFile("items.txt");
    printf("物品删除成功！\n");
}
```

### 5.6.2 界面访问控制

```cpp
// 在主消息循环中检查权限
void handleScreenAccess(ScreenState targetScreen) {
    // 管理员专属界面
    if (targetScreen == SCREEN_ADMIN_MENU ||
        targetScreen == SCREEN_ADMIN_ITEM_LIST ||
        targetScreen == SCREEN_ADMIN_USER_LIST) {
        
        if (!isAdmin()) {
            printf("错误：需要管理员权限才能访问此界面！\n");
            g_currentScreen = SCREEN_MAIN_MENU;  // 重定向到主菜单
            return;
        }
    }
    
    // 需要登录的界面
    if (targetScreen == SCREEN_ADD_ITEM ||
        targetScreen == SCREEN_CREDIT_PROFILE ||
        targetScreen == SCREEN_TRANSACTION_HISTORY) {
        
        if (g_currentUser == NULL) {
            printf("错误：请先登录！\n");
            g_currentScreen = SCREEN_USER_LOGIN;
            return;
        }
    }
    
    // 允许访问
    g_currentScreen = targetScreen;
}
```

---

## 5.7 数据完整性保护

### 5.7.1 级联删除

当删除用户时，需要处理关联数据：

```cpp
void deleteUserWithCascade(const char* username) {
    // 1. 删除用户发布的物品
    for (int i = g_itemCount - 1; i >= 0; i--) {
        if (strcmp(g_items[i].publisher, username) == 0) {
            deleteItemById(g_items[i].id);
        }
    }
    
    // 2. 删除用户的交易记录
    for (int i = g_transactionCount - 1; i >= 0; i--) {
        if (strcmp(g_transactions[i].sellerUsername, username) == 0 ||
            strcmp(g_transactions[i].buyerUsername, username) == 0) {
            deleteTransactionById(g_transactions[i].transactionId);
        }
    }
    
    // 3. 删除用户的评价
    for (int i = g_reviewCount - 1; i >= 0; i--) {
        if (strcmp(g_reviews[i].reviewerUsername, username) == 0 ||
            strcmp(g_reviews[i].reviewedUsername, username) == 0) {
            deleteReviewById(g_reviews[i].reviewId);
        }
    }
    
    // 4. 删除用户信誉档案
    for (int i = 0; i < MAX_USERS; i++) {
        if (strcmp(g_creditProfiles[i].username, username) == 0) {
            memset(&g_creditProfiles[i], 0, sizeof(UserCreditProfile));
            break;
        }
    }
    
    // 5. 最后删除用户账号
    deleteUserByUsername(username);
    
    // 6. 保存所有数据
    saveItemsToFile("items.txt");
    saveTransactionsToFile("transactions.txt");
    saveReviewsToFile("reviews.txt");
    saveCreditProfilesToFile("credit_profiles.txt");
    saveUsersToFile("users.txt");
}
```

**时间复杂度分析：**
```
设：
- n = 物品总数
- m = 交易总数
- k = 评价总数

级联删除：
- 删除物品：O(n?)（每次删除都要移动数组）
- 删除交易：O(m?)
- 删除评价：O(k?)
- 删除档案：O(1)
- 删除用户：O(u)，u为用户总数

总计：O(n? + m? + k?)

优化方案：
1. 使用标记删除：O(n + m + k)
2. 批量删除：先收集索引，再一次性删除
3. 使用链表：删除操作O(1)
```

### 5.7.2 软删除机制

```cpp
// 为所有实体添加 isDeleted 标志
typedef struct {
    int id;
    char name[MAX_NAME_LEN];
    // ... 其他字段
    bool isDeleted;
    time_t deletedTime;
    char deletedBy[MAX_USERNAME_LEN];
} Item;

// 软删除函数
void softDeleteItem(int itemId, const char* deletedBy) {
    Item* item = findItemById(itemId);
    if (item != NULL) {
        item->isDeleted = true;
        item->deletedTime = time(NULL);
        strcpy_s(item->deletedBy, MAX_USERNAME_LEN, deletedBy);
        
        saveItemsToFile("items.txt");
        printf("物品已标记为删除\n");
    }
}

// 恢复删除
void restoreItem(int itemId) {
    Item* item = findItemById(itemId);
    if (item != NULL && item->isDeleted) {
        item->isDeleted = false;
        item->deletedTime = 0;
        item->deletedBy[0] = '\0';
        
        saveItemsToFile("items.txt");
        printf("物品已恢复\n");
    }
}

// 定期清理（物理删除）
void cleanupDeletedItems(int daysOld) {
    time_t now = time(NULL);
    time_t threshold = now - (daysOld * 24 * 60 * 60);
    
    for (int i = g_itemCount - 1; i >= 0; i--) {
        if (g_items[i].isDeleted && g_items[i].deletedTime < threshold) {
            // 物理删除
            for (int j = i; j < g_itemCount - 1; j++) {
                g_items[j] = g_items[j + 1];
            }
            g_itemCount--;
        }
    }
    
    saveItemsToFile("items.txt");
}
```

---

## 5.8 审计日志系统

### 5.8.1 操作日志记录

```cpp
typedef struct {
    int logId;
    char username[MAX_USERNAME_LEN];
    char operation[100];  // 操作描述
    char targetType[20];  // 目标类型（用户/物品/交易）
    int targetId;         // 目标ID
    time_t timestamp;     // 时间戳
    char result[20];      // 结果（成功/失败）
} AuditLog;

AuditLog g_auditLogs[MAX_AUDIT_LOGS];
int g_auditLogCount = 0;

// 记录操作日志
void logOperation(const char* operation, const char* targetType, 
                 int targetId, const char* result) {
    if (g_auditLogCount >= MAX_AUDIT_LOGS) {
        return;  // 日志已满
    }
    
    AuditLog log;
    log.logId = g_auditLogCount + 1;
    
    if (g_currentUser != NULL) {
        strcpy_s(log.username, MAX_USERNAME_LEN, g_currentUser->username);
    } else {
        strcpy_s(log.username, MAX_USERNAME_LEN, "SYSTEM");
    }
    
    strcpy_s(log.operation, 100, operation);
    strcpy_s(log.targetType, 20, targetType);
    log.targetId = targetId;
    log.timestamp = time(NULL);
    strcpy_s(log.result, 20, result);
    
    g_auditLogs[g_auditLogCount++] = log;
    
    // 保存到文件
    appendAuditLogToFile("audit.log", &log);
}

// 使用示例
void deleteItemWithLogging(int itemId) {
    Item* item = findItemById(itemId);
    if (item == NULL) {
        logOperation("删除物品", "物品", itemId, "失败-未找到");
        return;
    }
    
    deleteItemById(itemId);
    saveItemsToFile("items.txt");
    
    logOperation("删除物品", "物品", itemId, "成功");
}
```

### 5.8.2 日志查询

```cpp
// 查询用户的操作历史
void displayUserAuditLogs(const char* username) {
    printf("\n=== %s 的操作历史 ===\n", username);
    printf("时间                 操作          目标类型  目标ID  结果\n");
    printf("------------------- ------------ -------- ------ ------\n");
    
    for (int i = 0; i < g_auditLogCount; i++) {
        if (strcmp(g_auditLogs[i].username, username) == 0) {
            char timeStr[20];
            strftime(timeStr, sizeof(timeStr), "%Y-%m-%d %H:%M:%S", 
                    localtime(&g_auditLogs[i].timestamp));
            
            printf("%-19s %-12s %-8s %-6d %-6s\n",
                   timeStr,
                   g_auditLogs[i].operation,
                   g_auditLogs[i].targetType,
                   g_auditLogs[i].targetId,
                   g_auditLogs[i].result);
        }
    }
    printf("=====================================\n");
}
```

---

## 5.9 技术难点与解决方案

### 难点1：防止误删管理员账号

**问题：**如果删除了所有管理员账号，系统将无法管理。

**解决方案：**

```cpp
bool canDeleteAdmin(const char* username) {
    // 1. 统计管理员数量
    int adminCount = countAdminUsers();
    
    // 2. 如果只有一个管理员，不允许删除
    if (adminCount <= 1) {
        printf("错误：不能删除最后一个管理员账号！\n");
        return false;
    }
    
    // 3. 不能删除当前登录的管理员
    if (g_currentUser != NULL && 
        strcmp(g_currentUser->username, username) == 0) {
        printf("错误：不能删除当前登录的账号！\n");
        return false;
    }
    
    return true;
}
```

### 难点2：大量数据的性能问题

**问题：**当物品和用户数量很大时，删除操作很慢。

**解决方案：**

1. **批量操作**
```cpp
void batchDeleteItems(int* itemIds, int count) {
    // 标记所有要删除的项
    for (int i = 0; i < count; i++) {
        Item* item = findItemById(itemIds[i]);
        if (item != NULL) {
            item->isDeleted = true;
        }
    }
    
    // 一次性压缩数组
    compactItems();
    
    // 一次性保存
    saveItemsToFile("items.txt");
}
```

2. **异步删除**
```cpp
// 将删除操作放入队列
void queueDelete(int itemId) {
    g_deleteQueue[g_deleteQueueCount++] = itemId;
}

// 后台线程处理删除
void processDeleteQueue() {
    while (g_deleteQueueCount > 0) {
        int itemId = g_deleteQueue[--g_deleteQueueCount];
        deleteItemById(itemId);
    }
    saveItemsToFile("items.txt");
}
```

### 难点3：数据一致性

**问题：**删除用户时，如何保证关联数据的一致性？

**解决方案：事务性操作**

```cpp
bool deleteUserTransaction(const char* username) {
    // 1. 备份数据
    User userBackup[MAX_USERS];
    Item itemBackup[MAX_ITEMS];
    memcpy(userBackup, g_users, sizeof(g_users));
    memcpy(itemBackup, g_items, sizeof(g_items));
    int userCountBackup = g_userCount;
    int itemCountBackup = g_itemCount;
    
    // 2. 执行删除操作
    bool success = true;
    
    if (!deleteUserItems(username)) {
        success = false;
    }
    
    if (success && !deleteUserTransactions(username)) {
        success = false;
    }
    
    if (success && !deleteUserByUsername(username)) {
        success = false;
    }
    
    // 3. 如果失败，回滚
    if (!success) {
        memcpy(g_users, userBackup, sizeof(g_users));
        memcpy(g_items, itemBackup, sizeof(g_items));
        g_userCount = userCountBackup;
        g_itemCount = itemCountBackup;
        printf("删除失败，已回滚！\n");
        return false;
    }
    
    // 4. 提交（保存到文件）
    saveUsersToFile("users.txt");
    saveItemsToFile("items.txt");
    
    return true;
}
```

---

## 小结

管理员功能模块实现了平台的后台管理能力：

1. **管理员登录**：三重验证机制，确保只有管理员可以访问
2. **物品管理**：查看所有物品，删除违规内容
3. **用户管理**：查看所有用户，删除违规账号
4. **权限控制**：基于角色的访问控制（RBAC）
5. **数据保护**：防止误删、级联删除、软删除
6. **审计日志**：记录所有管理操作，便于追溯

**关键技术：**
- 三重身份验证
- 基于角色的访问控制
- 级联删除机制
- 软删除与恢复
- 审计日志系统
- 事务性操作

**算法复杂度：**
- 管理员验证：O(n)
- 删除物品：O(n)
- 删除用户：O(n)
- 级联删除：O(n? + m? + k?)（可优化至O(n + m + k)）
- 权限检查：O(1)

**安全特性：**
- 防止删除最后一个管理员
- 防止删除当前登录账号
- 操作日志记录
- 数据备份与回滚

---

**全系列完成！**

至此，我们已经完整讲解了校园二手交易系统的所有功能模块：
1. 登录注册系统
2. 主菜单与物品浏览
3. 物品发布与详情查看
4. 信用评价系统与交易管理
5. 管理员功能模块

每个部分都包含详细的算法分析、代码实现、优化方案和安全考虑！
