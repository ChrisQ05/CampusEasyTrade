# 第三部分：物品发布与详情查看功能

## 3.1 物品发布功能

### 功能概述
用户可以通过物品发布界面将闲置物品发布到平台，填写物品名称、描述、价格和联系方式等信息。

### 核心数据结构

**1. 物品ID生成算法**

```cpp
int getNextItemId() {
    if (g_itemCount == 0) {
        return 1001;  // 初始ID从1001开始
    }
    
    // 查找当前最大ID
    int maxId = 0;
    for (int i = 0; i < g_itemCount; i++) {
        if (g_items[i].id > maxId) {
            maxId = g_items[i].id;
        }
    }
    
    return maxId + 1;  // 返回最大ID+1
}
```

**算法分析：**
- **时间复杂度**：O(n)，需要遍历所有物品
- **空间复杂度**：O(1)
- **优化方案**：维护全局最大ID变量，复杂度降至O(1)

```cpp
// 优化版本
static int g_maxItemId = 1000;

int getNextItemId() {
    return ++g_maxItemId;
}
```

### 核心技术实现

**1. 发布界面绘制 (`drawAddItemScreen`)**

```cpp
#define ADD_ITEM_INPUT_START_X 250
#define ADD_ITEM_LABEL_START_X 100
#define ADD_ITEM_FIELD_HEIGHT 35
#define ADD_ITEM_FIELD_SPACING 50
#define ADD_ITEM_INPUT_WIDTH 400

void drawAddItemScreen() {
    BeginBatchDraw();
    setbkcolor(RGB(240, 240, 255));
    cleardevice();
    
    // 绘制标题
    settextcolor(RGB(50, 50, 150));
    settextstyle(36, 0, "微软雅黑");
    outtextxy(300, 30, "发布新物品");
    
    settextcolor(BLACK);
    settextstyle(24, 0, "宋体");
    
    // 物品名称输入框
    outtextxy(ADD_ITEM_LABEL_START_X, 100, "物品名称:");
    drawInputField(ADD_ITEM_INPUT_START_X, 100, ADD_ITEM_INPUT_WIDTH, 
                   ADD_ITEM_FIELD_HEIGHT, g_add_itemNameBuffer, 
                   g_activeInputBox == 1);
    
    // 物品描述输入框
    outtextxy(ADD_ITEM_LABEL_START_X, 100 + ADD_ITEM_FIELD_SPACING, "物品描述:");
    drawInputField(ADD_ITEM_INPUT_START_X, 100 + ADD_ITEM_FIELD_SPACING, 
                   ADD_ITEM_INPUT_WIDTH, ADD_ITEM_FIELD_HEIGHT, 
                   g_add_itemDescBuffer, g_activeInputBox == 2);
    
    // 价格输入框
    outtextxy(ADD_ITEM_LABEL_START_X, 100 + 2 * ADD_ITEM_FIELD_SPACING, "价格 (元):");
    drawInputField(ADD_ITEM_INPUT_START_X, 100 + 2 * ADD_ITEM_FIELD_SPACING, 
                   ADD_ITEM_INPUT_WIDTH, ADD_ITEM_FIELD_HEIGHT, 
                   g_add_itemPriceBuffer, g_activeInputBox == 3);
    
    // 联系方式输入框
    outtextxy(ADD_ITEM_LABEL_START_X, 100 + 3 * ADD_ITEM_FIELD_SPACING, "联系方式:");
    drawInputField(ADD_ITEM_INPUT_START_X, 100 + 3 * ADD_ITEM_FIELD_SPACING, 
                   ADD_ITEM_INPUT_WIDTH, ADD_ITEM_FIELD_HEIGHT, 
                   g_add_itemContactBuffer, g_activeInputBox == 4);
    
    // 绘制按钮
    drawButton(200, 500, 150, 40, "提交发布");
    drawButton(450, 500, 150, 40, "返回主菜单");
    
    EndBatchDraw();
}
```

**布局算法：**
```
输入框Y坐标 = 基准Y + 索引 × 间距
Y = 100 + index × 50

输入框1: Y = 100 + 0 × 50 = 100
输入框2: Y = 100 + 1 × 50 = 150
输入框3: Y = 100 + 2 × 50 = 200
输入框4: Y = 100 + 3 × 50 = 250
```

**2. 物品发布逻辑 (`handleAddItemClick`)**

```cpp
void handleAddItemClick(ExMessage msg) {
    if (msg.message == WM_LBUTTONDOWN) {
        // === 1. 提交发布按钮 ===
        if (msg.x >= 200 && msg.x <= 350 && msg.y >= 500 && msg.y <= 540) {
            saveInputBufferContent();  // 保存当前输入
            
            // === 数据验证 ===
            // 1.1 非空验证
            if (strlen(g_add_itemNameBuffer) == 0 ||
                strlen(g_add_itemDescBuffer) == 0 ||
                strlen(g_add_itemPriceBuffer) == 0 ||
                strlen(g_add_itemContactBuffer) == 0) {
                printf("所有字段都不能为空！\n");
                return;
            }
            
            // 1.2 价格验证
            float price = (float)atof(g_add_itemPriceBuffer);
            if (price <= 0) {
                printf("价格必须是正数！\n");
                return;
            }
            
            // 1.3 容量检查
            if (g_itemCount >= MAX_ITEMS) {
                printf("物品列表已满！\n");
                return;
            }
            
            // === 创建新物品 ===
            Item newItem;
            newItem.id = getNextItemId();
            strcpy_s(newItem.name, MAX_NAME_LEN, g_add_itemNameBuffer);
            strcpy_s(newItem.description, MAX_DESC_LEN, g_add_itemDescBuffer);
            newItem.price = price;
            strcpy_s(newItem.contactInfo, MAX_CONTACT_LEN, g_add_itemContactBuffer);
            newItem.status = ITEM_STATUS_AVAILABLE;
            
            // 设置发布者信息
            if (g_currentUser != NULL) {
                strcpy_s(newItem.publisher, MAX_USERNAME_LEN, g_currentUser->username);
            } else {
                strcpy_s(newItem.publisher, MAX_USERNAME_LEN, "未知用户");
            }
            
            // === 添加到数组并保存 ===
            g_items[g_itemCount++] = newItem;
            saveItemsToFile("items.txt");
            
            printf("物品 '%s' (ID: %d) 已发布。\n", newItem.name, newItem.id);
            
            // === 清空输入并跳转 ===
            g_add_itemNameBuffer[0] = '\0';
            g_add_itemDescBuffer[0] = '\0';
            g_add_itemPriceBuffer[0] = '\0';
            g_add_itemContactBuffer[0] = '\0';
            g_inputBuffer[0] = '\0';
            g_activeInputBox = 0;
            g_currentScreen = SCREEN_ITEM_LIST;
            return;
        }
        
        // === 2. 输入框焦点切换 ===
        int clickedBox = 0;
        if (msg.x >= ADD_ITEM_INPUT_START_X && 
            msg.x <= ADD_ITEM_INPUT_START_X + ADD_ITEM_INPUT_WIDTH) {
            
            if (msg.y >= 100 && msg.y <= 135) {
                clickedBox = 1;  // 名称
            } else if (msg.y >= 150 && msg.y <= 185) {
                clickedBox = 2;  // 描述
            } else if (msg.y >= 200 && msg.y <= 235) {
                clickedBox = 3;  // 价格
            } else if (msg.y >= 250 && msg.y <= 285) {
                clickedBox = 4;  // 联系方式
            }
        }
        
        // 焦点切换逻辑
        if (clickedBox != 0 && clickedBox != g_activeInputBox) {
            saveInputBufferContent();
            g_activeInputBox = clickedBox;
            loadInputBufferContent(g_activeInputBox);
        } else if (clickedBox == 0 && g_activeInputBox != 0) {
            saveInputBufferContent();
            g_activeInputBox = 0;
        }
    }
}
```


**核心算法：数据验证流程**

```
输入：用户填写的表单数据
输出：验证通过/失败

验证流程：
1. 非空验证
   for each field in [name, desc, price, contact]:
       if field is empty:
           return FAIL("字段不能为空")

2. 类型验证
   price = parseFloat(priceBuffer)
   if price <= 0:
       return FAIL("价格必须为正数")

3. 容量验证
   if g_itemCount >= MAX_ITEMS:
       return FAIL("物品列表已满")

4. 权限验证
   if g_currentUser == NULL:
       return FAIL("请先登录")

5. 创建物品
   newItem = createItem(...)
   g_items[g_itemCount++] = newItem
   saveToFile()
   return SUCCESS

时间复杂度：O(1)
空间复杂度：O(1)
```

**3. 数据持久化 (`saveItemsToFile`)**

```cpp
int saveItemsToFile(const char* filename) {
    FILE* fp = fopen(filename, "w");
    if (fp == NULL) {
        return -1;
    }
    
    // 遍历所有物品，写入文件
    for (int i = 0; i < g_itemCount; i++) {
        fprintf(fp, "%d,%s,%s,%.2f,%d,%s,%s\n",
                g_items[i].id,
                g_items[i].name,
                g_items[i].description,
                g_items[i].price,
                g_items[i].status,
                g_items[i].contactInfo,
                g_items[i].publisher);
    }
    
    fclose(fp);
    return g_itemCount;
}
```

**数据格式：**
```
ID,名称,描述,价格,状态,联系方式,发布者
1001,二手自行车,9成新,150.00,0,13800138000,user1
1002,教材书籍,高数上册,20.00,0,13900139000,user2
```

**技术要点：**
- **CSV格式**：使用逗号分隔，便于解析
- **全量覆盖**：每次保存都重写整个文件
- **原子性**：先写入临时文件，再重命名（生产环境）

---

## 3.2 物品详情查看功能

### 功能概述
用户点击物品列表中的某一行，进入物品详情页面，查看完整信息并可进行购买或标记已售出操作。

### 核心技术实现

**1. 物品查找算法 (`findItemById`)**

```cpp
Item* findItemById(int id) {
    for (int i = 0; i < g_itemCount; i++) {
        if (g_items[i].id == id) {
            return &g_items[i];  // 返回指针
        }
    }
    return NULL;  // 未找到
}
```

**算法分析：**
- **算法类型**：线性查找（Sequential Search）
- **时间复杂度**：
  - 最好情况：O(1) - 第一个就是
  - 最坏情况：O(n) - 最后一个或不存在
  - 平均情况：O(n/2) ≈ O(n)
- **空间复杂度**：O(1)

**优化方案：**

方案1：使用哈希表
```cpp
// 使用ID作为键的哈希表
std::unordered_map<int, Item*> g_itemMap;

Item* findItemById(int id) {
    auto it = g_itemMap.find(id);
    return (it != g_itemMap.end()) ? it->second : NULL;
}
// 时间复杂度：O(1)
```

方案2：二分查找（需要ID有序）
```cpp
Item* findItemById(int id) {
    int left = 0, right = g_itemCount - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (g_items[mid].id == id) {
            return &g_items[mid];
        } else if (g_items[mid].id < id) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return NULL;
}
// 时间复杂度：O(log n)
// 前提：数组按ID排序
```

**2. 详情界面绘制 (`drawItemDetailsScreen`)**

```cpp
void drawItemDetailsScreen() {
    BeginBatchDraw();
    setbkcolor(RGB(230, 230, 250));  // 浅紫色背景
    cleardevice();
    
    // 绘制标题
    settextcolor(RGB(50, 50, 150));
    settextstyle(36, 0, "微软雅黑");
    outtextxy(280, 30, "物品详情");
    
    // 根据全局ID查找物品
    Item* item = findItemById(g_currentItemId);
    
    if (item != NULL) {
        settextcolor(BLACK);
        settextstyle(24, 0, "宋体");
        
        // 显示物品信息（左对齐标签，右侧显示内容）
        outtextxy(100, 100, "ID:");
        char idStr[10];
        sprintf_s(idStr, sizeof(idStr), "%d", item->id);
        outtextxy(250, 100, idStr);
        
        outtextxy(100, 140, "名称:");
        outtextxy(250, 140, item->name);
        
        outtextxy(100, 180, "描述:");
        outtextxy(250, 180, item->description);
        
        outtextxy(100, 220, "价格:");
        char priceStr[20];
        sprintf_s(priceStr, sizeof(priceStr), "%.2f 元", item->price);
        outtextxy(250, 220, priceStr);
        
        outtextxy(100, 260, "状态:");
        outtextxy(250, 260, item->status == ITEM_STATUS_AVAILABLE ? "在售" : "已售出");
        
        outtextxy(100, 300, "联系方式:");
        outtextxy(250, 300, item->contactInfo);
        
        outtextxy(100, 340, "发布者:");
        outtextxy(250, 340, item->publisher);
        
        // 根据用户身份显示不同按钮
        if (item->status == ITEM_STATUS_AVAILABLE) {
            if (g_currentUser != NULL && 
                strcmp(g_currentUser->username, item->publisher) == 0) {
                // 发布者：显示"标记已售出"按钮
                drawButton(200, 450, 150, 40, "标记已售出");
            } else {
                // 其他用户：显示"购买"按钮
                drawButton(200, 450, 150, 40, "购买");
            }
        }
    } else {
        settextcolor(RED);
        settextstyle(24, 0, "宋体");
        outtextxy(200, 200, "物品未找到或已删除！");
    }
    
    // 返回按钮
    drawButton(450, 450, 150, 40, "返回列表");
    
    EndBatchDraw();
}
```

**技术要点：**
- **动态按钮显示**：根据用户身份和物品状态显示不同操作
- **空指针检查**：物品可能已被删除，需要判断NULL
- **信息对齐**：使用固定X坐标实现标签和内容的对齐


**3. 购买功能实现 (`handleItemDetailsClick`)**

```cpp
void handleItemDetailsClick(ExMessage msg) {
    if (msg.message == WM_LBUTTONDOWN) {
        Item* item = findItemById(g_currentItemId);
        
        // 返回列表按钮
        if (msg.x >= 450 && msg.x <= 600 && msg.y >= 450 && msg.y <= 490) {
            g_currentScreen = SCREEN_ITEM_LIST;
            return;
        }
        
        // 操作按钮（购买/标记已售出）
        if (item != NULL && item->status == ITEM_STATUS_AVAILABLE &&
            msg.x >= 200 && msg.x <= 350 && msg.y >= 450 && msg.y <= 490) {
            
            // 登录检查
            if (g_currentUser == NULL) {
                printf("请先登录后再进行操作！\n");
                return;
            }
            
            // === 情况1：发布者标记已售出 ===
            if (strcmp(g_currentUser->username, item->publisher) == 0) {
                printf("准备标记 ID: %d 为已售出。\n", g_currentItemId);
                item->status = ITEM_STATUS_SOLD;
                saveItemsToFile("items.txt");
                printf("物品 '%s' (ID: %d) 已标记为已售出。\n", item->name, item->id);
                g_currentScreen = SCREEN_ITEM_LIST;
                return;
            }
            
            // === 情况2：其他用户购买 ===
            else {
                printf("准备购买物品 ID: %d\n", g_currentItemId);
                
                // 创建交易记录
                int transactionId = createTransaction(
                    item->id, 
                    item->publisher, 
                    g_currentUser->username, 
                    item->price
                );
                
                if (transactionId > 0) {
                    // 更新物品状态
                    item->status = ITEM_STATUS_SOLD;
                    saveItemsToFile("items.txt");
                    
                    // 保存交易记录
                    Transaction* createdTransaction = findTransactionById(transactionId);
                    if (createdTransaction == NULL ||
                        appendTransactionToFile("transactions.txt", createdTransaction) != 0) {
                        // 追加失败则全量保存
                        saveTransactionsToFile("transactions.txt");
                    }
                    
                    printf("购买成功！交易ID: %d\n", transactionId);
                    printf("物品 '%s' (ID: %d) 已售出给 %s\n", 
                           item->name, item->id, g_currentUser->username);
                    
                    // 跳转到交易历史页面
                    g_currentScreen = SCREEN_TRANSACTION_HISTORY;
                    return;
                } else {
                    printf("购买失败！\n");
                    return;
                }
            }
        }
    }
}
```

**核心算法：购买流程**

```
输入：物品ID，买家用户名
输出：交易成功/失败

购买流程：
1. 权限验证
   if currentUser == NULL:
       return FAIL("请先登录")
   
   if currentUser == item.publisher:
       return FAIL("不能购买自己的物品")

2. 状态检查
   if item.status != AVAILABLE:
       return FAIL("物品已售出")

3. 创建交易记录
   transaction = {
       id: getNextTransactionId(),
       itemId: item.id,
       seller: item.publisher,
       buyer: currentUser.username,
       price: item.price,
       time: getCurrentTime(),
       status: PENDING
   }
   
4. 更新物品状态
   item.status = SOLD
   saveItems()

5. 保存交易记录
   saveTransaction(transaction)

6. 更新用户信誉
   updateCreditProfile(seller)
   updateCreditProfile(buyer)

7. 跳转到交易历史
   currentScreen = TRANSACTION_HISTORY

时间复杂度：O(n)，主要是保存文件操作
空间复杂度：O(1)
```

---

## 3.3 搜索功能

### 功能概述
用户可以通过关键词搜索物品，系统在物品名称和描述中进行模糊匹配。

### 核心算法实现

**1. 字符串匹配算法 (`searchItems`)**

```cpp
void searchItems(const char* keyword) {
    printf("\n--- 搜索物品 ---\n");
    
    if (strlen(keyword) == 0) {
        printf("关键词不能为空。\n");
        return;
    }
    
    printf("\n--- 搜索结果 ---\n");
    g_searchResultCount = 0;  // 重置搜索结果数量
    
    printf("ID    名称                  价格      状态      联系方式\n");
    printf("---- -------------------- -------- --------- --------------------\n");
    
    // 遍历所有物品，进行模糊匹配
    for (int i = 0; i < g_itemCount; i++) {
        // 使用 strstr 进行子串查找
        if (strstr(g_items[i].name, keyword) != NULL ||
            strstr(g_items[i].description, keyword) != NULL) {
            
            // 将匹配的物品添加到搜索结果数组
            if (g_searchResultCount < MAX_SEARCH_RESULTS) {
                g_searchResults[g_searchResultCount++] = g_items[i];
            }
            
            // 打印搜索结果
            printf("%-4d %-20s %-8.2f %-9s %-20s\n",
                   g_items[i].id,
                   g_items[i].name,
                   g_items[i].price,
                   g_items[i].status ? "已售出" : "在售",
                   g_items[i].contactInfo);
        }
    }
    
    if (g_searchResultCount == 0) {
        printf("未找到与关键词 '%s' 匹配的物品。\n", keyword);
    }
    printf("------------------------------------------------------------------\n");
}
```

**算法分析：**

**算法类型**：暴力字符串匹配（Brute Force String Matching）

**时间复杂度分析：**
```
设：
- n = 物品总数
- m = 每个物品名称/描述的平均长度
- k = 关键词长度

strstr() 的时间复杂度：O(m × k)

总时间复杂度：O(n × m × k)

实际场景：
- n ≈ 100（物品数量）
- m ≈ 50（名称+描述长度）
- k ≈ 5（关键词长度）
- 总计：100 × 50 × 5 = 25,000 次字符比较

对于小规模数据，性能完全可接受
```

**优化方案：**

方案1：KMP算法
```cpp
// KMP算法实现
int* buildNext(const char* pattern, int m) {
    int* next = (int*)malloc(m * sizeof(int));
    next[0] = -1;
    int j = -1;
    for (int i = 1; i < m; i++) {
        while (j >= 0 && pattern[i] != pattern[j + 1]) {
            j = next[j];
        }
        if (pattern[i] == pattern[j + 1]) {
            j++;
        }
        next[i] = j;
    }
    return next;
}

bool kmpSearch(const char* text, const char* pattern) {
    int n = strlen(text);
    int m = strlen(pattern);
    int* next = buildNext(pattern, m);
    
    int j = -1;
    for (int i = 0; i < n; i++) {
        while (j >= 0 && text[i] != pattern[j + 1]) {
            j = next[j];
        }
        if (text[i] == pattern[j + 1]) {
            j++;
        }
        if (j == m - 1) {
            free(next);
            return true;  // 找到匹配
        }
    }
    free(next);
    return false;
}

// 时间复杂度：O(n + m)，比暴力算法快
```

方案2：倒排索引
```cpp
// 为每个关键词建立倒排索引
struct InvertedIndex {
    char keyword[20];
    int itemIds[MAX_ITEMS];
    int count;
};

InvertedIndex g_index[1000];  // 假设1000个关键词

// 建立索引（预处理）
void buildIndex() {
    for (int i = 0; i < g_itemCount; i++) {
        // 分词并建立索引
        char* words = tokenize(g_items[i].name);
        for (each word in words) {
            addToIndex(word, g_items[i].id);
        }
    }
}

// 搜索（O(1)查找）
void searchWithIndex(const char* keyword) {
    InvertedIndex* index = findIndex(keyword);
    if (index != NULL) {
        for (int i = 0; i < index->count; i++) {
            displayItem(index->itemIds[i]);
        }
    }
}

// 时间复杂度：O(1)查找 + O(k)显示，k为结果数量
```

**2. 搜索结果界面 (`drawSearchResultScreen`)**

```cpp
void drawSearchResultScreen() {
    BeginBatchDraw();
    setbkcolor(RGB(255, 255, 220));
    cleardevice();
    
    settextcolor(RGB(50, 50, 150));
    settextstyle(36, 0, "微软雅黑");
    outtextxy(300, 30, "搜索物品");
    
    // 搜索输入框
    settextcolor(BLACK);
    settextstyle(24, 0, "宋体");
    outtextxy(SEARCH_LABEL_START_X, 100, "关键词:");
    drawInputField(SEARCH_INPUT_START_X, 100, SEARCH_INPUT_WIDTH, 
                   ADD_ITEM_FIELD_HEIGHT, g_search_keywordBuffer, 
                   g_activeInputBox == 10);
    
    drawButton(200, 180, 150, 40, "搜索");
    drawButton(450, 180, 150, 40, "返回主菜单");
    
    // 显示搜索结果
    settextcolor(BLACK);
    settextstyle(20, 0, "宋体");
    outtextxy(ITEM_LIST_START_X, SEARCH_RESULT_START_Y, 
             "ID    名称            价格    状态     联系方式");
    line(ITEM_LIST_START_X, SEARCH_RESULT_START_Y + ITEM_ROW_HEIGHT,
         ITEM_LIST_START_X + 700, SEARCH_RESULT_START_Y + ITEM_ROW_HEIGHT);
    
    int currentY = SEARCH_RESULT_START_Y + ITEM_ROW_HEIGHT + 5;
    int displayedCount = 0;
    
    if (strlen(g_search_keywordBuffer) > 0) {
        for (int i = 0; i < g_itemCount; i++) {
            // 在名称或描述中查找关键词，且状态为在售
            if (g_items[i].status == ITEM_STATUS_AVAILABLE &&
                (strstr(g_items[i].name, g_search_keywordBuffer) != NULL ||
                 strstr(g_items[i].description, g_search_keywordBuffer) != NULL)) {
                
                if (displayedCount < SEARCH_ITEMS_PER_PAGE) {
                    // 显示物品信息
                    char idStr[10];
                    sprintf_s(idStr, sizeof(idStr), "%d", g_items[i].id);
                    outtextxy(ITEM_LIST_START_X, currentY, idStr);
                    
                    outtextxy(ITEM_LIST_START_X + 60, currentY, g_items[i].name);
                    
                    char priceStr[20];
                    sprintf_s(priceStr, sizeof(priceStr), "%.2f", g_items[i].price);
                    outtextxy(ITEM_LIST_START_X + 260, currentY, priceStr);
                    
                    outtextxy(ITEM_LIST_START_X + 360, currentY, "在售");
                    outtextxy(ITEM_LIST_START_X + 460, currentY, g_items[i].contactInfo);
                    
                    currentY += ITEM_ROW_HEIGHT;
                    displayedCount++;
                }
            }
        }
    }
    
    // 显示提示信息
    if (displayedCount == 0 && strlen(g_search_keywordBuffer) > 0) {
        outtextxy(ITEM_LIST_START_X + 10, currentY, "未找到匹配的物品");
    } else if (strlen(g_search_keywordBuffer) == 0) {
        outtextxy(ITEM_LIST_START_X + 10, currentY, "请输入关键词进行搜索");
    }
    
    EndBatchDraw();
}
```


---

## 3.4 技术难点与解决方案

### 难点1：多输入框焦点管理

**问题：**系统中有多个界面，每个界面有多个输入框，如何统一管理焦点？

**解决方案：**
1. 使用全局变量 `g_activeInputBox` 标识当前激活的输入框
2. 为每个输入框分配唯一ID（1-12）
3. 使用 `saveInputBufferContent()` 和 `loadInputBufferContent()` 实现数据同步

**代码实现：**
```cpp
// 焦点切换流程
if (clickedBox != 0 && clickedBox != g_activeInputBox) {
    saveInputBufferContent();           // 1. 保存旧焦点的数据
    g_activeInputBox = clickedBox;      // 2. 切换焦点
    loadInputBufferContent(clickedBox); // 3. 加载新焦点的数据
}
```

### 难点2：数据验证的完整性

**问题：**用户输入可能包含非法数据，如何确保数据有效性？

**解决方案：**实现多层验证机制

```cpp
// 验证层次结构
1. 前端验证（UI层）
   - 输入框长度限制
   - 字符类型过滤（只允许数字、字母等）

2. 业务逻辑验证
   - 非空验证
   - 格式验证（价格必须为正数）
   - 唯一性验证（用户名不重复）

3. 数据库层验证
   - 容量检查（数组是否已满）
   - 完整性约束（外键关系）
```

**完整验证示例：**
```cpp
bool validateItemData(const Item* item) {
    // 1. 非空验证
    if (strlen(item->name) == 0) {
        printf("错误：物品名称不能为空\n");
        return false;
    }
    
    // 2. 长度验证
    if (strlen(item->name) > MAX_NAME_LEN - 1) {
        printf("错误：物品名称过长\n");
        return false;
    }
    
    // 3. 数值范围验证
    if (item->price <= 0 || item->price > 999999) {
        printf("错误：价格必须在0-999999之间\n");
        return false;
    }
    
    // 4. 格式验证
    if (!isValidPhoneNumber(item->contactInfo)) {
        printf("错误：联系方式格式不正确\n");
        return false;
    }
    
    return true;
}
```

### 难点3：文件I/O的原子性

**问题：**保存数据时程序崩溃，可能导致数据丢失或损坏。

**解决方案：**使用临时文件 + 重命名的原子操作

```cpp
int saveItemsToFileSafe(const char* filename) {
    char tempFilename[256];
    sprintf_s(tempFilename, sizeof(tempFilename), "%s.tmp", filename);
    
    // 1. 写入临时文件
    FILE* fp = fopen(tempFilename, "w");
    if (fp == NULL) {
        return -1;
    }
    
    for (int i = 0; i < g_itemCount; i++) {
        fprintf(fp, "%d,%s,%s,%.2f,%d,%s,%s\n",
                g_items[i].id, g_items[i].name, g_items[i].description,
                g_items[i].price, g_items[i].status, 
                g_items[i].contactInfo, g_items[i].publisher);
    }
    
    fclose(fp);
    
    // 2. 重命名临时文件（原子操作）
    if (remove(filename) != 0) {
        // 原文件不存在，忽略错误
    }
    
    if (rename(tempFilename, filename) != 0) {
        printf("错误：无法保存文件\n");
        return -1;
    }
    
    return g_itemCount;
}
```

**原子性保证：**
- `rename()` 是原子操作，要么成功要么失败
- 失败时原文件不受影响
- 成功时新数据完整替换旧数据

### 难点4：内存管理与指针安全

**问题：**使用指针返回物品数据，可能导致悬空指针。

**解决方案：**

方案1：返回指针（当前实现）
```cpp
Item* findItemById(int id) {
    for (int i = 0; i < g_itemCount; i++) {
        if (g_items[i].id == id) {
            return &g_items[i];  // 返回数组元素的地址
        }
    }
    return NULL;
}

// 使用时必须检查NULL
Item* item = findItemById(id);
if (item != NULL) {
    // 安全使用
}
```

**风险：**
- 数组重新分配时指针失效
- 删除元素时指针指向错误位置

方案2：返回索引（更安全）
```cpp
int findItemIndexById(int id) {
    for (int i = 0; i < g_itemCount; i++) {
        if (g_items[i].id == id) {
            return i;  // 返回索引
        }
    }
    return -1;  // 未找到
}

// 使用
int index = findItemIndexById(id);
if (index >= 0) {
    Item* item = &g_items[index];  // 每次使用时重新获取指针
}
```

方案3：返回副本（最安全但效率低）
```cpp
bool findItemById(int id, Item* outItem) {
    for (int i = 0; i < g_itemCount; i++) {
        if (g_items[i].id == id) {
            *outItem = g_items[i];  // 复制整个结构体
            return true;
        }
    }
    return false;
}

// 使用
Item item;
if (findItemById(id, &item)) {
    // 使用副本，不受原数组影响
}
```

---

## 小结

物品发布与详情查看系统实现了以下核心功能：

1. **物品发布**：用户可以发布二手物品，系统自动生成ID并保存
2. **数据验证**：多层验证机制确保数据完整性和有效性
3. **物品详情**：展示完整物品信息，支持购买和标记已售出
4. **搜索功能**：支持关键词模糊搜索，快速定位目标物品
5. **购买流程**：完整的购买流程，自动创建交易记录

**关键技术：**
- ID自动生成算法
- 多输入框焦点管理
- 数据验证机制
- 字符串匹配算法（strstr）
- 文件I/O原子操作
- 指针安全管理

**算法复杂度总结：**
- ID生成：O(n)（可优化至O(1)）
- 物品查找：O(n)（可优化至O(log n)或O(1)）
- 搜索功能：O(n × m × k)
- 数据保存：O(n)
- 数据验证：O(1)

**优化方向：**
1. 使用哈希表优化查找（O(1)）
2. 使用KMP算法优化搜索（O(n + m)）
3. 使用倒排索引优化搜索（O(1)查找）
4. 使用数据库替代文件存储
5. 实现增量保存减少I/O开销

---

**下一部分预告：信用评价系统与交易管理**

